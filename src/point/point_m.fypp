! Module  : point_m
! Purpose : Define point_t datatype, for representing points

#:include 'forum.inc'

module point_m

   ! Uses

   use forum_m

   use transform_m
   use vector_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Derived-type definitions

   type :: point_t
      real(RD) :: x
      real(RD) :: y
      real(RD) :: z
   contains
      private
      procedure             :: equals_
      generic, public       :: operator(==) => equals_
      procedure             :: add_point_vector_
      procedure, pass(self) :: add_vector_point_
      generic, public       :: operator(+) => add_point_vector_, add_vector_point_
      procedure             :: sub_point_point_
      generic, public       :: operator(-) => sub_point_point_
      procedure, public     :: image
   end type point_t

   ! Interfaces

   interface

      ! In point_operate_sm

      elemental module function equals_(self, other) result(equals)
         implicit none (type, external)
         class(point_t), intent(in) :: self
         type(point_t), intent(in)  :: other
         logical                    :: equals
      end function equals_

      elemental module function add_point_vector_(self, vector) result(point)
         implicit none (type, external)
         class(point_t), intent(in) :: self
         type(vector_t), intent(in) :: vector
         type(point_t)              :: point
      end function add_point_vector_

      elemental module function add_vector_point_(vector, self) result(point)
         implicit none (type, external)
         type(vector_t), intent(in) :: vector
         class(point_t), intent(in) :: self
         type(point_t)              :: point
      end function add_vector_point_

      elemental module function sub_point_point_(self, other) result(vector)
         implicit none (type, external)
         class(point_t), intent(in) :: self
         type(point_t), intent(in)  :: other
         type(vector_t)             :: vector
      end function sub_point_point_

      ! In vector_transform_sm

      impure elemental module function image(self, tform) result(point)
         implicit none (type, external)
         class(point_t), intent(in)    :: self
         type(transform_t), intent(in) :: tform
         type(point_t)                 :: point
      end function image

   end interface

   interface to_array
      #:for rank in range(1, RANK_MAX)
         module procedure to_array_${rank}$_
      #:endfor
   end interface to_array

   interface from_array
      #:for rank in range(1, RANK_MAX)
         module procedure from_array_${rank}$_
      #:endfor
   end interface from_array

   interface affine_sum
      module procedure affine_sum_
   end interface affine_sum

   interface reallocate
      module procedure reallocate_point_t_1_
   end interface reallocate

   ! Accessibility

   private

   public :: point_t
   public :: to_array
   public :: from_array
   public :: affine_sum
   public :: reallocate

   ! Procedures

contains

   function affine_sum_(points, weights) result(point)

      type(point_t), intent(in) :: points(:)
      real(RD), intent(in)      :: weights(:)
      type(point_t)             :: point

      @:CHECK_BOUNDS(SIZE(weights), SIZE(points))

      ! Evaluate the affine sum of the points. It is assumed (but not
      ! checked!) that SUM(weights) = 1

      point%x = SUM(points%x*weights)
      point%y = SUM(points%y*weights)
      point%z = SUM(points%z*weights)

      ! Finish

      return

   end function affine_sum_

   !****

   #:for rank in range(1, RANK_MAX)

      subroutine to_array_${rank}$_(points, coords)

         type(point_t), intent(in)          :: points${ARRAY_SPEC(rank)}$
         real(RD), allocatable, intent(out) :: coords${ARRAY_SPEC(rank+1)}$

         integer :: shape_points(${rank}$)
         integer :: shape_coords(${rank+1}$)

         ! Convert the array of points into an (3,...) array of point coordinates

         shape_points = SHAPE(points)
         shape_coords = [3, shape_points]

         coords = RESHAPE( &
            TRANSFER(points, MOLD=0._RD, SIZE=PRODUCT(shape_coords)), &
            SHAPE=shape_coords)

         ! Finish

         return

      end subroutine to_array_${rank}$_

      !****

      subroutine from_array_${rank}$_(coords, points)

         real(RD), intent(in)                    :: coords${ARRAY_SPEC(rank+1)}$
         type(point_t), allocatable, intent(out) :: points${ARRAY_SPEC(rank)}$

         integer :: shape_coords(${rank+1}$)
         integer :: shape_points(${rank}$)

         @:CHECK_BOUNDS(SIZE(coords, 1), 3)

         ! Convert the (3,...)  array of point coordinates into an array of points

         shape_coords = SHAPE(coords)
         shape_points = shape_coords(2:)

         points = RESHAPE( &
            TRANSFER(coords, MOLD=point_t(0._RD, 0._RD, 0._RD), SIZE=PRODUCT(shape_points)), &
            SHAPE=shape_points)

         ! Finish

         return

      end subroutine from_array_${rank}$_

   #:endfor

   !****

   $:REALLOCATE('type(point_t)', 'point_t', 1)

end module point_m
