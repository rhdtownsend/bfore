! Module  : point_m
! Purpose : Define point_t datatype, for representing points

#:include 'forum.inc'

module point_m

   ! Uses

   use forum_m

   use transform_m
   use vector_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Derived-type definitions

   type :: point_t
      real(RD) :: x
      real(RD) :: y
      real(RD) :: z
   contains
      private
      procedure             :: equals_
      generic, public       :: operator(==) => equals_
      procedure             :: add_point_vector_
      procedure, pass(self) :: add_vector_point_
      generic, public       :: operator(+) => add_point_vector_, add_vector_point_
      procedure             :: sub_point_point_
      generic, public       :: operator(-) => sub_point_point_
      procedure, public     :: image
      procedure, public     :: to_polar
   end type point_t

   ! Interfaces

   ! In point_operate_sm

   interface

      elemental module function equals_(self, other) result(equals)
         implicit none (type, external)
         class(point_t), intent(in) :: self
         type(point_t), intent(in)  :: other
         logical                    :: equals
      end function equals_

      elemental module function add_point_vector_(self, vector) result(point)
         implicit none (type, external)
         class(point_t), intent(in) :: self
         type(vector_t), intent(in) :: vector
         type(point_t)              :: point
      end function add_point_vector_

      elemental module function add_vector_point_(vector, self) result(point)
         implicit none (type, external)
         type(vector_t), intent(in) :: vector
         class(point_t), intent(in) :: self
         type(point_t)              :: point
      end function add_vector_point_

      elemental module function sub_point_point_(self, other) result(vector)
         implicit none (type, external)
         class(point_t), intent(in) :: self
         type(point_t), intent(in)  :: other
         type(vector_t)             :: vector
      end function sub_point_point_

   end interface

   ! In point_transform_sm

   interface

      impure elemental module function image(self, tform) result(point)
         implicit none (type, external)
         class(point_t), intent(in)    :: self
         type(transform_t), intent(in) :: tform
         type(point_t)                 :: point
      end function image

      elemental module subroutine to_polar(self, r, theta, phi)
         implicit none (type, external)
         class(point_t), intent(in) :: self
         real(RD), intent(out)      :: r
         real(RD), intent(out)      :: theta
         real(RD), intent(out)      :: phi
      end subroutine to_polar

   end interface

   ! In point_array_sm

   interface to_array

      #:for rank in range(0, RANK_MAX)
         module subroutine to_array_${rank}$_(points, coords)
            implicit none (type, external)
            type(point_t), intent(in) :: points${ARRAY_SPEC(rank)}$
            real(RD), intent(out)     :: coords${ARRAY_SPEC(rank+1)}$
         end subroutine to_array_${rank}$_
      #:endfor

   end interface to_array

   interface from_array

      #:for rank in range(0, RANK_MAX)
         module subroutine from_array_${rank}$_(coords, points)
            implicit none (type, external)
            real(RD), intent(in)       :: coords${ARRAY_SPEC(rank+1)}$
            type(point_t), intent(out) :: points${ARRAY_SPEC(rank)}$
         end subroutine from_array_${rank}$_
      #:endfor

   end interface from_array

   interface reallocate
      module procedure reallocate_point_t_1_
   end interface reallocate

   ! In this file

   interface affine_sum
      module procedure affine_sum_
   end interface affine_sum

   ! Accessibility

   private

   public :: point_t
   public :: to_array
   public :: from_array
   public :: reallocate
   public :: affine_sum

   ! Procedures

contains

   function affine_sum_(points, weights) result(point)

      type(point_t), intent(in) :: points(:)
      real(RD), intent(in)      :: weights(:)
      type(point_t)             :: point

      @:CHECK_BOUNDS(SIZE(weights), SIZE(points))

      ! Evaluate the affine sum of the points. It is assumed (but not
      ! checked!) that SUM(weights) = 1

      point%x = SUM(points%x*weights)
      point%y = SUM(points%y*weights)
      point%z = SUM(points%z*weights)

      ! Finish

      return

   end function affine_sum_

   !****

   $:REALLOCATE('type(point_t)', 'point_t', 1)

end module point_m
