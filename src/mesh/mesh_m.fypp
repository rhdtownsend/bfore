! Module  : mesh_m
! Purpose : Define mesh_t datatype, for representing triangular surface
!           meshes

#:include 'forum.inc'

module mesh_m

   ! Uses

   use forum_m

   use stat_m
   use point_m
   use vector_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Parameter definitions

   integer, parameter :: BOUNDARY_EDGE = -HUGE(0)

   ! Derived-type definitions

   type :: mesh_t
      private
      integer, allocatable        :: EV(:)   ! Edge-vertex table
      integer, allocatable        :: ET(:)   ! Edge-twin table
      integer, allocatable        :: VE(:)   ! Vertex-edge table
      type(point_t), allocatable  :: VP(:)   ! Vertex-point table
      real(RD), allocatable       :: VS(:,:) ! Vertex-scalar table
      type(vector_t), allocatable :: VV(:,:) ! Vertex-vector table
      integer, public             :: n_scalar
      integer, public             :: n_vector
      integer, public             :: n_vert
      integer, public             :: n_edge
      integer, public             :: n_face
   contains
      private
      procedure         :: equals_
      generic, public   :: operator(==) => equals_
      procedure, public :: edge_prev
      procedure, public :: edge_next
      procedure, public :: edge_twin
      procedure, public :: vert_edge
      procedure, public :: vert_face
      procedure, public :: edge_vert
      procedure, public :: edge_face
      procedure, public :: face_vert
      procedure, public :: face_edge
      procedure, public :: flip_edge
      procedure, public :: refine_face
      procedure, public :: refine
      procedure, public :: refine_and_flip
      procedure, public :: vert_point
      procedure, public :: vert_scalar
      procedure, public :: vert_vector
      procedure, public :: face_area
      procedure, public :: validate
      procedure, public :: euler_characteristic
      procedure, public :: read
      procedure, public :: write
   end type mesh_t

   ! Interfaces

   interface mesh_t
      module procedure mesh_t_face_verts_
      module procedure mesh_t_merge_
   end interface mesh_t

   interface

      ! In mesh_construct_sm

      module function mesh_t_data_(EV, ET, VE, VP, VS, VV) result(mesh)
         implicit none (type, external)
         integer, intent(in)        :: EV(:)
         integer, intent(in)        :: ET(:)
         integer, intent(in)        :: VE(:)
         type(point_t), intent(in)  :: VP(:)
         real(RD), intent(in)       :: VS(:,:)
         type(vector_t), intent(in) :: VV(:,:)
         type(mesh_t)               :: mesh
      end function mesh_t_data_

      module function mesh_t_face_verts_(face_verts, vert_coords, n_scalar, n_vector) result(mesh)
         implicit none (type, external)
         integer, intent(in)            :: face_verts(:,:)
         real(RD), intent(in)           :: vert_coords(:,:)
         integer, intent(in), optional  :: n_scalar
         integer, intent(in), optional  :: n_vector
         type(mesh_t)                   :: mesh
      end function mesh_t_face_verts_

      module function mesh_t_merge_(meshes) result(mesh)
         implicit none (type, external)
         type(mesh_t), intent(in) :: meshes(:)
         type(mesh_t)             :: mesh
      end function mesh_t_merge_

      ! In mesh_operate_sm

      module function equals_(self, other) result(equals)
         implicit none (type, external)
         class(mesh_t), intent(in) :: self
         type(mesh_t), intent(in)  :: other
         logical                   :: equals
      end function equals_

      ! In mesh_connect_sm

      impure elemental module function edge_prev(self, e) result(e_p)
         implicit none (type, external)
         class(mesh_t), intent(in) :: self
         integer, intent(in)       :: e
         integer                   :: e_p
      end function edge_prev

      impure elemental module function edge_next(self, e) result(e_n)
         implicit none (type, external)
         class(mesh_t), intent(in) :: self
         integer, intent(in)       :: e
         integer                   :: e_n
      end function edge_next

      impure elemental module function edge_twin(self, e) result(e_t)
         implicit none (type, external)
         class(mesh_t), intent(in) :: self
         integer, intent(in)       :: e
         integer                   :: e_t
      end function edge_twin

      impure elemental module function vert_edge(self, v) result(v_e)
         implicit none (type, external)
         class(mesh_t), intent(in) :: self
         integer, intent(in)       :: v
         integer                   :: v_e
      end function vert_edge

      impure elemental module function vert_face(self, v) result(v_f)
         implicit none (type, external)
         class(mesh_t), intent(in) :: self
         integer, intent(in)       :: v
         integer                   :: v_f
         integer :: v_e
      end function vert_face

      impure elemental module function edge_vert(self, e) result(e_v)
         implicit none (type, external)
         class(mesh_t), intent(in) :: self
         integer, intent(in)       :: e
         integer                   :: e_v
      end function edge_vert

      impure elemental module function edge_face(self, e) result(e_f)
         implicit none (type, external)
         class(mesh_t), intent(in)      :: self
         integer, intent(in)            :: e
         integer                        :: e_f
      end function edge_face

      impure elemental module function face_vert(self, f) result(f_v)
         implicit none (type, external)
         class(mesh_t), intent(in) :: self
         integer, intent(in)       :: f
         integer                   :: f_v
      end function face_vert

      impure elemental module function face_edge(self, f) result(f_e)
         implicit none (type, external)
         class(mesh_t), intent(in) :: self
         integer, intent(in)       :: f
         integer                   :: f_e
      end function face_edge

      module subroutine validate(self, stat, loc)
         implicit none (type, external)
         class(mesh_t), intent(in)      :: self
         integer, intent(out)           :: stat
         integer, intent(out), optional :: loc
      end subroutine validate

      module function euler_characteristic(self) result(chi)
         implicit none (type, external)
         class(mesh_t), intent(in) :: self
         integer                   :: chi
      end function euler_characteristic

      ! In mesh_modify_sm

      module subroutine flip_edge(self, e, clockwise)
         implicit none (type, external)
         class(mesh_t), intent(inout)  :: self
         integer, intent(in)           :: e
         logical, intent(in), optional :: clockwise
      end subroutine flip_edge

      module subroutine refine_face(self, f, v_new)
         implicit none (type, external)
         class(mesh_t), intent(inout) :: self
         integer, intent(in)          :: f
         integer, intent(out)         :: v_new
      end subroutine refine_face

      module subroutine refine(self, v_new)
         implicit none (type, external)
         class(mesh_t), intent(inout)      :: self
         integer, allocatable, intent(out) :: v_new(:)
      end subroutine refine

      module subroutine refine_and_flip(self, v, clockwise)
         implicit none (type, external)
         class(mesh_t), intent(inout)      :: self
         integer, allocatable, intent(out) :: v(:)
         logical, intent(in), optional     :: clockwise
      end subroutine refine_and_flip

      ! In mesh_vert_sm

      module function vert_point(self, v) result(point)
         implicit none (type, external)
         class(mesh_t), intent(in), target :: self
         integer, intent(in)               :: v
         type(point_t), pointer            :: point
      end function vert_point

      module function vert_scalar(self, i, v) result(scalar)
         implicit none (type, external)
         class(mesh_t), intent(in), target :: self
         integer, intent(in)               :: i
         integer, intent(in)               :: v
         real(RD), pointer                 :: scalar
      end function vert_scalar

      module function vert_vector(self, i, v) result(vector)
         implicit none (type, external)
         class(mesh_t), intent(in), target :: self
         integer, intent(in)               :: i
         integer, intent(in)               :: v
         type(vector_t), pointer           :: vector
      end function vert_vector

      ! In mesh_face_sm

      module function face_area(self, f) result(A)
         implicit none (type, external)
         class(mesh_t), intent(in), target :: self
         integer, intent(in)               :: f
         type(vector_t)                    :: A
      end function face_area

      ! In mesh_io_sm

      module subroutine read(self, hdf5io, stat)
         implicit none (type, external)
         class(mesh_t), intent(out)     :: self
         type(hdf5io_t), intent(inout)  :: hdf5io
         integer, intent(out), optional :: stat
      end subroutine read

      module subroutine write(self, hdf5io, stat)
         implicit none (type, external)
         class(mesh_t), intent(in)      :: self
         type(hdf5io_t), intent(inout)  :: hdf5io
         integer, intent(out), optional :: stat
      end subroutine write

   end interface

   ! Accessibility

   private

   public :: BOUNDARY_EDGE
   public :: mesh_t

end module mesh_m
