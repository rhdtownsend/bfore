! Module  : mesh_primitives_m
! Purpose : Create mesh_t types for polyhedral and other primitives

#:include 'forum.inc'

module mesh_primitives_m

   ! Uses

   use forum_m

   use mesh_m
   use point_m
   use polar_surface_m
   use vector_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Accessibility

   private

   public :: one_face_mesh
   public :: two_face_mesh
   public :: tetrahedron_mesh
   public :: icosahedron_mesh
   public :: polar_mesh

   ! Procedures

contains

   function one_face_mesh(n_scalar, n_vector) result(mesh)

      integer, intent(in), optional :: n_scalar
      integer, intent(in), optional :: n_vector
      type(mesh_t)                  :: mesh

      integer  :: face_verts(3,1)
      real(RD) :: vert_coords(3,3)

      ! Create a single-face mesh_t

      face_verts(:,1) = [1, 2, 3]

      vert_coords(:,1) = [1._RD, 0._RD, 0._RD]
      vert_coords(:,2) = [0._RD, 1._RD, 0._RD]
      vert_coords(:,3) = [0._RD, 0._RD, 1._RD]

      mesh = mesh_t(face_verts, vert_coords, n_scalar, n_vector)

      ! Finish

      return

   end function one_face_mesh

   !****

   function two_face_mesh(n_scalar, n_vector) result(mesh)

      integer, intent(in), optional :: n_scalar
      integer, intent(in), optional :: n_vector
      type(mesh_t)                  :: mesh

      integer  :: face_verts(3,2)
      real(RD) :: vert_coords(3,4)

      ! Create a two-face mesh_t

      face_verts(:,1) = [1, 2, 3]
      face_verts(:,2) = [2, 4, 3]

      vert_coords(:,1) = [1._RD, 0._RD, 0._RD]
      vert_coords(:,2) = [0._RD, 1._RD, 0._RD]
      vert_coords(:,3) = [0._RD, 0._RD, 1._RD]
      vert_coords(:,4) = [1._RD, 1._RD, -1._RD]

      mesh = mesh_t(face_verts, vert_coords, n_scalar, n_vector)

      ! Finish

      return

   end function two_face_mesh

   !***

   function tetrahedron_mesh(n_scalar, n_vector) result(mesh)

      integer, intent(in), optional :: n_scalar
      integer, intent(in), optional :: n_vector
      type(mesh_t)                  :: mesh

      real(RD), parameter :: SQRT_1_9 = SQRT(1._RD/9._RD)
      real(RD), parameter :: SQRT_2_9 = SQRT(2._RD/9._RD)
      real(RD), parameter :: SQRT_6_9 = SQRT(6._RD/9._RD)
      real(RD), parameter :: SQRT_8_9 = SQRT(8._RD/9._RD)

      integer  :: face_verts(3,4)
      real(RD) :: vert_coords(3,4)

      ! Create a tetrahedron mesh_t (to fit inside unit sphere, with
      ! bottom face parallel to xy plane)

      face_verts(:,1) = [1, 2, 3]
      face_verts(:,2) = [2, 1, 4]
      face_verts(:,3) = [3, 4, 1]
      face_verts(:,4) = [4, 3, 2]

      vert_coords(:,1) = [SQRT_8_9, 0._RD, -SQRT_1_9]
      vert_coords(:,2) = [-SQRT_2_9, -SQRT_6_9, -SQRT_1_9]
      vert_coords(:,3) = [-SQRT_2_9, SQRT_6_9, -SQRT_1_9]
      vert_coords(:,4) = [0._RD, 0._RD, 1._RD]

      mesh = mesh_t(face_verts, vert_coords, n_scalar, n_vector)

      ! Finish

      return

   end function tetrahedron_mesh

   !****

   function icosahedron_mesh_old(n_scalar, n_vector) result(mesh)

      integer, intent(in), optional :: n_scalar
      integer, intent(in), optional :: n_vector
      type(mesh_t)                  :: mesh

      real(RD), parameter :: PHI = (SQRT(5._RD) + 1._RD)/2._RD

      integer  :: face_verts(3, 20)
      real(RD) :: vert_coords(3, 12)

      ! Create an icosahedron mesh_t (to fit inside cube with side
      ! length 2*PHI)

      face_verts(:,1) = [1, 12, 6]
      face_verts(:,2) = [1, 6, 2]
      face_verts(:,3) = [1, 2, 8]
      face_verts(:,4) = [1, 8, 11]
      face_verts(:,5) = [1, 11, 12]
      face_verts(:,6) = [2, 6, 10]
      face_verts(:,7) = [6, 12, 5]
      face_verts(:,8) = [12, 11, 3]
      face_verts(:,9) = [11, 8, 7]
      face_verts(:,10) = [8, 2, 9]
      face_verts(:,11) = [4, 10, 5]
      face_verts(:,12) = [4, 5, 3]
      face_verts(:,13) = [4, 3, 7]
      face_verts(:,14) = [4, 7, 9]
      face_verts(:,15) = [4, 9, 10]
      face_verts(:,16) = [5, 10, 6]
      face_verts(:,17) = [3, 5, 12]
      face_verts(:,18) = [7, 3, 11]
      face_verts(:,19) = [9, 7, 8]
      face_verts(:,20) = [10, 9, 2]

      vert_coords(:,1) = [-1._RD,  phi,  0._RD]
      vert_coords(:,2) = [1._RD,  phi,  0._RD]
      vert_coords(:,3) = [-1._RD, -phi,  0._RD]
      vert_coords(:,4) = [1._RD, -phi,  0._RD]
      vert_coords(:,5) = [0._RD, -1._RD,  phi]
      vert_coords(:,6) = [0._RD,  1._RD,  phi]
      vert_coords(:,7) = [0._RD, -1._RD, -phi]
      vert_coords(:,8) = [0._RD,  1._RD, -phi]
      vert_coords(:,9) = [ phi,  0._RD, -1._RD]
      vert_coords(:,10) = [ phi,  0._RD,  1._RD]
      vert_coords(:,11) = [-phi,  0._RD, -1._RD]
      vert_coords(:,12) = [-phi,  0._RD,  1._RD]

      mesh = mesh_t(face_verts, vert_coords, n_scalar, n_vector)

      ! Finish

      return

   end function icosahedron_mesh_old

   !****

   function icosahedron_mesh(n_scalar, n_vector) result(mesh)

      integer, intent(in), optional :: n_scalar
      integer, intent(in), optional :: n_vector
      type(mesh_t)                  :: mesh

      integer  :: face_verts(3, 20)
      real(RD) :: vert_coords(3, 12)
      integer  :: i
      real(RD) :: theta
      real(RD) :: phi

      ! Create an icosahedron mesh_t, with top/bottom vertices at [0,0,1] and [0,0,-1]

      face_verts(:,1) = [1, 4, 5]
      face_verts(:,2) = [1, 3, 4]
      face_verts(:,3) = [1, 2, 3]
      face_verts(:,4) = [1, 6, 2]
      face_verts(:,5) = [1, 5, 6]
      face_verts(:,6) = [5, 4, 9]
      face_verts(:,7) = [4, 3, 8]
      face_verts(:,8) = [3, 2, 7]
      face_verts(:,9) = [2, 6, 11]
      face_verts(:,10) = [6, 5, 10]
      face_verts(:,11) = [4, 8, 9]
      face_verts(:,12) = [3, 7, 8]
      face_verts(:,13) = [2, 11, 7]
      face_verts(:,14) = [6, 10, 11]
      face_verts(:,15) = [5, 9, 10]
      face_verts(:,16) = [12, 9, 8]
      face_verts(:,17) = [12, 8, 7]
      face_verts(:,18) = [12, 7, 11]
      face_verts(:,19) = [12, 11, 10]
      face_verts(:,20) = [12, 10, 9]

      vert_coords(:,1) = [0._RD, 0._RD, 1._RD]

      do i = 1, 5

         theta = ATAN(2._RD)
         phi = (i-1._RD)*TWOPI/5._RD
         vert_coords(:,i+1) = [COS(phi)*SIN(theta), SIN(phi)*SIN(theta), COS(theta)]

         theta = PI - ATAN(2._RD)
         phi = (i-0.5_RD)*TWOPI/5._RD
         vert_coords(:,i+6) = [COS(phi)*SIN(theta), SIN(phi)*SIN(theta), COS(theta)]

      enddo

      vert_coords(:,12) = [0._RD, 0._RD, -1._RD]

      mesh = mesh_t(face_verts, vert_coords, n_scalar, n_vector)

      ! Finish

      return

   end function icosahedron_mesh

   !****

   function polar_mesh(surf, n_refine, n_scalar, n_vector) result(mesh)

      class(polar_surface_t), intent(in) :: surf
      integer, intent(in)                :: n_refine
      integer, intent(in), optional      :: n_scalar
      integer, intent(in), optional      :: n_vector
      type(mesh_t)                       :: mesh

      integer              :: i
      integer, allocatable :: v(:)

      ! Create a mesh defined via a polar_surface, by refining an
      ! icosahedron mesh

      mesh = icosahedron_mesh(n_scalar, n_vector)

      call to_surf_([(i, i=1,mesh%n_vert)])

      refline_loop: do i = 1, n_refine
         call mesh%refine_and_flip(v)
         call to_surf_(v)
      end do refline_loop

      ! Finish

      return

   contains

      subroutine to_surf_(v)

         integer, intent(in) :: v(:)

         integer                 :: j
         type(point_t), pointer  :: point
         real(RD)                :: r
         real(RD)                :: theta
         real(RD)                :: phi

         do j = 1, SIZE(v)

            point => mesh%vert_point(v(j))

            call point%to_polar(r, theta, phi)

            point = surf%point(theta, phi)


         end do

      end subroutine to_surf_

   end function polar_mesh

end module mesh_primitives_m
