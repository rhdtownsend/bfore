! Submodule : mesh_construct_sm
! Purpose   : Constructor routines for mesh_t

#:include 'forum.inc'

submodule (mesh_m) mesh_construct_sm

   ! Uses

   use forum_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Procedures

contains

   module procedure mesh_t_data_

      @:CHECK_BOUNDS(SIZE(ET), SIZE(EV))

      !@:CHECK_BOUNDS(SIZE(VP, 1), 3)

      ! Construct the mesh_t from the supplied data

      mesh%n_vert = SIZE(VP)
      mesh%n_edge = SIZE(EV)
      mesh%n_face = SIZE(EV)/3
      mesh%n_scalar = SIZE(VS, 1)
      mesh%n_vector = SIZE(VV, 1)

      mesh%EV = EV
      mesh%ET = ET
      mesh%VE = VE
      mesh%VP = VP
      mesh%VS = VS
      mesh%VV = VV

      ! Finish

      return

   end procedure mesh_t_data_

   !****

   module procedure mesh_t_face_verts_

      integer                     :: n_scalar_
      integer                     :: n_vector_
      integer                     :: n_vert
      integer                     :: n_edge
      integer                     :: n_face
      integer, allocatable        :: EV(:)
      integer, allocatable        :: ET(:)
      integer, allocatable        :: VE(:)
      type(point_t), allocatable  :: VP(:)
      real(RD), allocatable       :: VS(:,:)
      type(vector_t), allocatable :: VV(:,:)

      @:CHECK_BOUNDS(SIZE(face_verts, 1), 3)

      if (PRESENT(n_scalar)) then
         n_scalar_ = n_scalar
      else
         n_scalar_ = 0
      end if

      if (PRESENT(n_vector)) then
         n_vector_ = n_vector
      else
         n_vector_ = 0
      end if

      ! Construct the mesh_t from the supplied face-vertex list

      n_vert = SIZE(vert_coords, 2)
      n_edge = 3*SIZE(face_verts, 2)
      n_face = SIZE(face_verts, 2)

      ! Set up the edge-vertex table

      allocate(EV(n_edge))
      EV = RESHAPE(face_verts, [n_edge])

      ! Re-order entries in the table that have incorrect orientations

      block

         logical :: face_mask(n_face)

         integer :: f1
         integer :: f2
         integer :: i1
         integer :: i2
         integer :: e1
         integer :: e2
         integer :: e1_n
         integer :: e2_n
         integer :: v

         face_mask = .FALSE.

         face_1_loop: do f1 = 1, n_face

            do i1 = 1, 3

               e1 = 3*(f1 - 1) + i1
               e1_n = 3*(f1 - 1) + MODULO(i1, 3) + 1

               face_2_loop: do f2 = f1+1, n_face

                  do i2 = 1, 3

                     e2 = 3*(f2 - 1) + i2
                     e2_n = 3*(f2 - 1) + MODULO(i2, 3) + 1

                     if (EV(e1) == EV(e2) .AND. EV(e1_n) == EV(e2_n)) then

                        @:ASSERT(.NOT. face_mask(f2), 'unorientable mesh')

                        v = EV(e2)
                        EV(e2) = EV(e2_n)
                        EV(e2_n) = v

                        face_mask(f2) = .TRUE.

                     end if

                  end do

               end do face_2_loop

            end do

         end do face_1_loop

      end block

      ! Set up the edge-twin table

      allocate(ET(n_edge))
      ET = BOUNDARY_EDGE

      block

         integer :: f1
         integer :: f2
         integer :: i1
         integer :: i2
         integer :: e1
         integer :: e2
         integer :: e1_n
         integer :: e2_n

         face_1_loop: do f1 = 1, n_face

            do i1 = 1, 3

               e1 = 3*(f1 - 1) + i1
               e1_n = 3*(f1 - 1) + MODULO(i1, 3) + 1

               face_2_loop: do f2 = f1+1, n_face

                  do i2 = 1, 3

                     e2 = 3*(f2 - 1) + i2
                     e2_n = 3*(f2 - 1) + MODULO(i2, 3) + 1

                     if (EV(e1) == EV(e2_n) .AND. EV(e1_n) == EV(e2)) then

                        ET(e1) = e2
                        ET(e2) = e1

                     end if

                  end do

               end do face_2_loop

            end do

         end do face_1_loop

      end block

      ! Set up the vertex-edge table

      allocate(VE(n_vert))
      VE = 0

      block

         integer :: e
         integer :: v

         edge_loop: do e = 1, n_edge

            v = EV(e)

            if (v > 0) then
               if (VE(v) == 0) VE(v) = e
            end if

         end do edge_loop

      end block

      ! Set up the vertex-point table

      allocate(VP(n_vert))
      call from_array(vert_coords, VP)

      ! Set up empty scalar and vector tables

      allocate(VS(n_scalar_,n_vert))
      VS = 0._RD

      allocate(VV(n_vector_,n_vert))
      VV = vector_t(0._RD, 0._RD, 0._RD)

      ! Create the mesh_t

      mesh = mesh_t_data_(EV, ET, VE, VP, VS, VV)

      ! Finish

      return

   end procedure mesh_t_face_verts_

   !****

   module procedure mesh_t_merge_

      integer                     :: n_vert
      integer                     :: n_face
      integer                     :: n_edge
      integer                     :: n_scalar
      integer                     :: n_vector
      integer, allocatable        :: EV(:)
      integer, allocatable        :: ET(:)
      integer, allocatable        :: VE(:)
      type(point_t), allocatable  :: VP(:)
      real(RD), allocatable       :: VS(:,:)
      type(vector_t), allocatable :: VV(:,:)
      integer                     :: i
      integer                     :: e1
      integer                     :: e2
      integer                     :: v1
      integer                     :: v2

      @:ASSERT_DEBUG(SIZE(meshes) >= 1, 'invalid dimension')

      @:ASSERT_DEBUG(ALL(meshes%n_scalar == meshes(1)%n_scalar), 'invalid dimension')
      @:ASSERT_DEBUG(ALL(meshes%n_vector == meshes(1)%n_vector), 'invalid dimension')

      ! Construct the mesh_t by merging meshes

      n_vert = SUM(meshes%n_vert)
      n_edge = SUM(meshes%n_edge)
      n_face = SUM(meshes%n_face)
      n_scalar = meshes(1)%n_scalar
      n_vector = meshes(1)%n_vector

      ! Set up concatenated tables

      allocate(EV(n_edge))
      allocate(ET(n_edge))
      allocate(VE(n_vert))
      allocate(VP(n_vert))
      allocate(VS(n_scalar,n_vert))
      allocate(VV(n_vector,n_vert))

      mesh_loop: do i = 1, SIZE(meshes)

         e1 = SUM(meshes(:i-1)%n_edge) + 1
         e2 = e1 + meshes(i)%n_edge - 1

         EV(e1:e2) = meshes(i)%EV + SUM(meshes(:i-1)%n_vert)
         ET(e1:e2) = MERGE(meshes(i)%ET + SUM(meshes(:i-1)%n_edge), meshes(i)%ET, meshes(i)%ET /= BOUNDARY_EDGE)

         v1 = SUM(meshes(:i-1)%n_vert) + 1
         v2 = v1 + meshes(i)%n_vert - 1

         VE(v1:v2) = meshes(i)%VE + SUM(meshes(:i-1)%n_edge)

         VP(v1:v2) = meshes(i)%VP

         VS(:,v1:v2) = meshes(i)%VS
         VV(:,v1:v2) = meshes(i)%VV

      end do mesh_loop

      ! Create the mesh_t

      mesh = mesh_t_data_(EV, ET, VE, VP, VS, VV)

      ! Finish

      return

   end procedure mesh_t_merge_

end submodule mesh_construct_sm
