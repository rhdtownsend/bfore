! Submodule : mesh_construct_sm
! Purpose   : Constructor routines for mesh_t

#:include 'forum.inc'

submodule (mesh_m) mesh_construct_sm

   ! Uses

   use forum_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Procedures

contains

   module procedure mesh_t_data_

      @:CHECK_BOUNDS(SIZE(ET), SIZE(EV))

      @:CHECK_BOUNDS(SIZE(VP, 1), 3)

      ! Construct the mesh_t from the supplied data

      mesh%n_vert = SIZE(VP, 2)
      mesh%n_edge = SIZE(EV)
      mesh%n_face = SIZE(EV)/3

      mesh%EV = EV
      mesh%ET = ET
      mesh%VE = VE
      mesh%VP = VP

      ! Finish

      return

   end procedure mesh_t_data_

   !****

   module procedure mesh_t_face_verts_

      integer               :: n_vert
      integer               :: n_edge
      integer               :: n_face
      integer, allocatable  :: EV(:)
      integer, allocatable  :: ET(:)
      integer, allocatable  :: VE(:)
      real(RD), allocatable :: VP(:,:)

      @:CHECK_BOUNDS(SIZE(face_verts, 1), 3)
      @:CHECK_BOUNDS(SIZE(vert_points, 1), 3)
   
      ! Construct the mesh_t from the supplied face-vertex list

      n_vert = SIZE(vert_points, 2)
      n_edge = 3*SIZE(face_verts, 2)
      n_face = SIZE(face_verts, 2)

      ! Set up the edge-vertex table

      allocate(EV(n_edge))
      EV = RESHAPE(face_verts, [n_edge])

      ! Re-order entries in the table that have incorrect orientations

      block

         logical :: face_mask(n_face)

         integer :: f1
         integer :: f2
         integer :: i1
         integer :: i2
         integer :: e1
         integer :: e2
         integer :: e1_n
         integer :: e2_n
         integer :: v

         face_mask = .FALSE.

         face_1_loop: do f1 = 1, n_face

            do i1 = 1, 3

               e1 = 3*(f1 - 1) + i1
               e1_n = 3*(f1 - 1) + MODULO(i1, 3) + 1

               face_2_loop: do f2 = f1+1, n_face

                  do i2 = 1, 3

                     e2 = 3*(f2 - 1) + i2
                     e2_n = 3*(f2 - 1) + MODULO(i2, 3) + 1

                     if (EV(e1) == EV(e2) .AND. EV(e1_n) == EV(e2_n)) then

                        @:ASSERT(.NOT. face_mask(f2), 'unorientable mesh')

                        v = EV(e2)
                        EV(e2) = EV(e2_n)
                        EV(e2_n) = v

                        face_mask(f2) = .TRUE.

                     end if

                  end do

               end do face_2_loop

            end do

         end do face_1_loop

      end block

      ! Set up the edge-twin table

      allocate(ET(n_edge))
      ET = BOUNDARY_EDGE

      block

         integer :: f1
         integer :: f2
         integer :: i1
         integer :: i2
         integer :: e1
         integer :: e2
         integer :: e1_n
         integer :: e2_n

         face_1_loop: do f1 = 1, n_face

            do i1 = 1, 3

               e1 = 3*(f1 - 1) + i1
               e1_n = 3*(f1 - 1) + MODULO(i1, 3) + 1

               face_2_loop: do f2 = f1+1, n_face

                  do i2 = 1, 3

                     e2 = 3*(f2 - 1) + i2
                     e2_n = 3*(f2 - 1) + MODULO(i2, 3) + 1

                     if (EV(e1) == EV(e2_n) .AND. EV(e1_n) == EV(e2)) then

                        ET(e1) = e2
                        ET(e2) = e1

                     end if

                  end do

               end do face_2_loop

            end do

         end do face_1_loop
         
      end block

      ! Set up the vertex-edge table

      allocate(VE(n_vert))
      VE = 0

      block

         integer :: e
         integer :: v

         edge_loop: do e = 1, n_edge

            v = EV(e)

            if (v > 0) then
               if (VE(v) == 0) VE(v) = e
            end if

         end do edge_loop

      end block

      ! Set up the vertex-point table

      VP = vert_points

      ! Create the mesh_t

      mesh = mesh_t_data_(EV, ET, VE, VP)

      ! Finish

      return

   end procedure mesh_t_face_verts_

   !****

   module procedure mesh_t_meshes_

      integer               :: n_vert
      integer               :: n_face
      integer               :: n_edge
      integer, allocatable  :: EV(:)
      integer, allocatable  :: ET(:)
      integer, allocatable  :: VE(:)
      real(RD), allocatable :: VP(:,:)
      integer               :: m
      integer               :: e1
      integer               :: e2
      integer               :: v1
      integer               :: v2
   
      @:ASSERT_DEBUG(SIZE(meshes) >= 1)

      ! Construct the mesh_t by concatenating the meshes

      n_vert = SUM(meshes%n_vert)
      n_edge = SUM(meshes%n_edge)
      n_face = SUM(meshes%n_face)

      ! Set up concatenated tables

      allocate(EV(n_edge))
      allocate(ET(n_edge))
      allocate(VE(n_vert))
      allocate(VP(3,n_vert))

      mesh_loop: do m = 1, SIZE(meshes)

         e1 = SUM(meshes(:m-1)%n_edge) + 1
         e2 = e1 + meshes(m)%n_edge - 1

         EV(e1:e2) = meshes(m)%EV + SUM(meshes(:m-1)%n_vert)
         ET(e1:e2) = MERGE(meshes(m)%ET + SUM(meshes(:m-1)%n_edge), meshes(m)%ET, meshes(m)%ET /= BOUNDARY_EDGE)

         v1 = SUM(meshes(:m-1)%n_vert) + 1
         v2 = v1 + meshes(m)%n_vert - 1

         VE(v1:v2) = meshes(m)%VE + SUM(meshes(:m-1)%n_edge)
         VP(:,v1:v2) = meshes(m)%VP

      end do mesh_loop

      ! Create the mesh_t

      mesh = mesh_t_data_(EV, ET, VE, VP)

      ! Finish

      return

   end procedure mesh_t_meshes_

end submodule mesh_construct_sm

