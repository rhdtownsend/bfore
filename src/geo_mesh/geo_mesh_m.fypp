! Module  : geo_mesh_m
! Purpose : Define gmesh_t datatype, which adds geometric data to
!           the mesh_t type

#:include 'forum.inc'

module geo_mesh_m

   ! Uses

   use forum_m
   use mesh_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type, extends(mesh_t) :: geo_mesh_t
      private
      real(RD), allocatable :: VC(:,:) ! Vertex-coordinate table
   contains
      private
      procedure, public :: vert_coord
      procedure, public :: face_area_vect
      procedure, public :: face_area
      procedure, public :: face_normal_vect
      procedure, public :: refine_face
      procedure, public :: refine
      procedure, public :: read
      procedure, public :: write
  end type geo_mesh_t

   ! Interfaces

   interface geo_mesh_t
      module procedure geo_mesh_t_vert_coords_
      module procedure geo_mesh_t_geo_meshes_
   end interface geo_mesh_t

   interface compare
      module procedure compare_
   end interface compare

   interface

      ! In geo_mesh_construct_sm

      module function geo_mesh_t_vert_coords_(mesh, vert_coords) result(geo_mesh)
         type(mesh_t), intent(in) :: mesh
         real(RD), intent(in)     :: vert_coords(:,:)
         type(geo_mesh_t)         :: geo_mesh
      end function geo_mesh_t_vert_coords_

      module function geo_mesh_t_geo_meshes_(geo_meshes) result(geo_mesh)
         type(geo_mesh_t), intent(in) :: geo_meshes(:)
         type(geo_mesh_t)             :: geo_mesh
      end function geo_mesh_t_geo_meshes_

      ! In geo_mesh_modify_sm

      module subroutine refine_face(self, f, v)
         class(geo_mesh_t), intent(inout) :: self
         integer, intent(in)              :: f
         integer, intent(out)             :: v
      end subroutine refine_face

      module subroutine refine(self, v)
         class(geo_mesh_t), intent(inout)  :: self
         integer, allocatable, intent(out) :: v(:)
      end subroutine refine

      ! In mesh_io_sm

      module subroutine read(self, hdf5io, stat)
         class(geo_mesh_t), intent(out) :: self
         type(hdf5io_t), intent(inout)  :: hdf5io
         integer, intent(out), optional :: stat
      end subroutine read

      module subroutine write(self, hdf5io, stat)
         class(geo_mesh_t), intent(in)  :: self
         type(hdf5io_t), intent(inout)  :: hdf5io
         integer, intent(out), optional :: stat
      end subroutine write

   end interface

   ! Accessibility

   private

   public :: geo_mesh_t
   public :: compare

   ! Procedures

contains

   function vert_coord(self, v) result(c)

      class(geo_mesh_t), intent(in), target :: self
      integer, intent(in)                :: v
      real(RD), pointer, contiguous      :: c(:)

      @:ASSERT_DEBUG(v >= 1 .AND. v <= self%n_vert, 'invalid vertex')

      ! Get the coordinates of vertex v. Can also be used to set the
      ! coordinates

      c => self%VC(:,v)

      ! Finish

      return

   end function vert_coord
      
   !****

   function face_area_vect(self, f) result(S)

      class(geo_mesh_t), intent(in) :: self
      integer, intent(in)        :: f
      real(RD)                   :: S(3)

      integer  :: f_e
      integer  :: v1
      integer  :: v2
      integer  :: v3
      real(RD) :: c1(3)
      real(RD) :: c2(3)
      real(RD) :: c3(3)
      real(RD) :: a1(3)
      real(RD) :: a2(3)

      ! Get the area vector of face f

      f_e = self%face_edge(f)

      v1 = self%edge_vert(f_e)
      v2 = self%edge_vert(self%edge_next(f_e))
      v3 = self%edge_vert(self%edge_prev(f_e))

      c1 = self%vert_coord(v1)
      c2 = self%vert_coord(v2)
      c3 = self%vert_coord(v3)

      a1 = c2 - c1
      a2 = c3 - c1

      S(1) = 0.5_RD*(a1(2)*a2(3) - a1(3)*a2(2))
      S(2) = 0.5_RD*(a1(3)*a2(1) - a1(1)*a2(3))
      S(3) = 0.5_RD*(a1(1)*a2(2) - a1(2)*a2(1))

      ! Finish

      return

   end function face_area_vect

   !****

   function face_area(self, f) result(A)

      class(geo_mesh_t), intent(in) :: self
      integer, intent(in)        :: f
      real(RD)                   :: A

      real(RD) :: S(3)

      ! Get the area of face f

      S = self%face_area_vect(f)

      A = NORM2(S)

      ! Finish

      return

   end function face_area

   !****

   function face_normal_vect(self, f) result(N)

      class(geo_mesh_t), intent(in) :: self
      integer, intent(in)        :: f
      real(RD)                   :: N(3)

      real(RD) :: S(3)

      ! Get the normal of face f

      S = self%face_area_vect(f)

      N = S/NORM2(S)

      ! Finish

      return
      
   end function face_normal_vect

   !****

   function compare_(mesh_a, mesh_b) result(same)

      type(geo_mesh_t), intent(in) :: mesh_a
      type(geo_mesh_t), intent(in) :: mesh_b
      logical                      :: same

      ! Compare the two geo_meshes

      same = compare(mesh_a%mesh_t, mesh_b%mesh_t)

      if (.NOT. same) return

      same = &
         ALL(mesh_a%VC == mesh_b%VC)

      ! Finish

      return

   end function compare_

end module geo_mesh_m
