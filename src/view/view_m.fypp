! Module  : view_m
! Purpose : Define view_t datatype, for transforming world
!           coordinates to window coordinates

#:include 'forum.inc'

module view_m

   ! Uses

   use forum_m

   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Derived-type definitions

   type :: view_t
      private
      real(RD) :: matrix_v(4,4) ! For transforming vectors
      real(RD) :: matrix_c(4,4) ! For transforming coordinates
   contains
      private
      public :: transform_vector
      public :: transform_coord
   end type view_t

   ! Interfaces

   interface view_t
      module procedure view_t_camera_
   end interface view_t

   ! Accessibility

   private

   public :: view_t

   ! Procedures

contains

   function view_t_euler_(alpha, beta, gamma, x_min, x_max, y_min, y_max) result(view)

      real(RD), intent(in) :: alpha
      real(RD) ,intent(in) :: beta
      real(RD), intent(in) :: gamma
      real(RD), intent(in) :: x_min
      real(RD), intent(in) :: x_max
      real(RD), intent(in) :: y_min
      real(RD), intent(in) :: y_max

      real(RD) :: rot_matrix(4,4)
      real(RD) :: trans_matrix_a(4,4)
      real(RD) :: trans_matrix_b(4,4)
      real(RD) :: scale_matrix(4,4)

      ! Construct the view_t from the supplied euler angles and window
      ! dimension

      ! Set up the matrix for transforming vectors from the world
      ! system to the window system

      view%matrix_v = rot_matrix_3_(alpha, beta, gamma)

      ! Set up the matrix for transforming coordinates from the world
      ! system to the window system

      view%matrix_c = rot_matrix_4_(alpha, beta, gamma)
      view%matrix_c = MATMUL(trans_matrix_(-x_min, -y_min, 0._RD), view%matrix_c)
      view%matrix_c = MATMUL(scale_matrix_(2._RD/(x_max-x_min), 2._RD/(y_max-y_min), 1._RD), view%matrix_c)
      view%matrix_c = MATMUL(trans_matrix_(-1._RD, -1._RD, 0._RD), view%matrix_c)

      ! Finish

      return

   end function view_t_euler_

   !****

   function vector_(self, w) result(w)

      real(RD), intent(in) :: w(:)

      @:CHECK_BOUNDS(SIZE(w), 3)

      ! Transform the vector h to the window system

      h(1:3) = w
      h(4) = 0._RD

      V_w = MATMUL(self%matrix_v, h)

      ! Finish

      return

   end function vector_

   !****

   function coord_(w) result(w)

      real(RD), intent(in) :: w(:)

      @:CHECK_BOUNDS(SIZE(w), 3)

      ! Transform the homogeneous coordinates to the window system

   !****

   function rot_matrix_3_(alpha, beta, gamma) result(R)

      real(RD), intent(in) :: alpha
      real(RD), intent(in) :: beta
      real(RD), intent(in) :: gamma
      real(RD)             :: R(3,3)

      ! Construct the 3-matrix for rotating a vector by a set of Euler
      ! angles:
      !
      !  alpha : first rotation, about z-axis
      !  beta : second rotation, about y'-axis
      !  gamma : third rotation, about z'-axis
      !
      ! This follows the convention by Korn & Korn (1968,
      ! 'Mathematical Handbook for Scientists and Engineers')

      cos_alpha = COS(alpha)
      sin_alpha = SIN(alpha)

      cos_beta = COS(beta)
      sin_beta = SIN(beta)

      cos_gamma = COS(gamma)
      sin_gamma = SIN(gamma)

      R(1,1) = cos_alpha*cos_beta*cos_gamma - sin_alpha*sin_gamma
      R(2,1) = sin_alpha*cos_beta*cos_gamma + cos_alpha*sin_gamma
      R(3,1) = -sin_beta*cos_gamma
      R(4,1) = 0._RD

      R(1,2) = -cos_alpha*cos_beta*sin_gamma - sin_alpha*cos_gamma
      R(2,2) = -sin_alpha*cos_beta*sin_gamma + cos_alpha*cos_gamma
      R(3,2) = sin_beta*sin_gamma
      R(4,2) = 0._RD

      R(1,3) = cos_alpha*sin_beta
      R(2,3) = sin_alpha*sin_beta
      R(3,3) = cos_beta
      R(4,3) = 0._RD

      R(1,4) = 0._RD
      R(2,4) = 0._RD
      R(3,4) = 0._RD
      R(4,4) = 1._RD

      ! Finish

      return

   end function rot_matrix_3_

   !****

   function rot_matrix_4_(alpha, beta, gamma) result(R)

      ! Construct the 4-matrix for rotating a vector by a set of Euler
      ! angles:
      !
      !  alpha : first rotation, about z-axis
      !  beta : second rotation, about y'-axis
      !  gamma : third rotation, about z'-axis
      !
      ! This follows the convention by Korn & Korn (1968,
      ! 'Mathematical Handbook for Scientists and Engineers') 

      !****

   function trans_matrix_(dx, dy, dz) result(T)

      real(RD), intent(in) :: dx
      real(RD), intent(in) :: dy
      real(RD), intent(in) :: dz
      real(RD)             :: D(4,4)

      ! Construct the matrix for translating a homogeneous vector by
      ! [dx, dy, dz]

      D(:,1) = [1._RD, 0._RD, 0._RD, 0._RD]
      D(:,2) = [0._RD, 1._RD, 0._RD, 0._RD]
      D(:,3) = [0._RD, 0._RD, 1._RD, 0._RD]
      D(:,4) = [dx,    dy,    dz,    1._RD]

      ! Finish

      return

   end function trans_matrix_

   !****

   function scale_matrix_(sx, sy, sx) result(S)

      real(RD), intent(in) :: sx
      real(RD), intent(in) :: sy
      real(RD), intent(in) :: sz
      real(RD)             :: S(4,4)

      ! Construct the matrix for scaling a homogeneous vector by [sx,
      ! sy, sz]

      S(:,1) = [sx   , 0._RD, 0._RD, 0._RD]
      S(:,2) = [0._RD, sy   , 0._RD, 0._RD]
      S(:,3) = [0._RD, 0._RD, sz   , 0._RD]
      S(:,4) = [0._RD, 0._RD, 0._RD, 1._RD]

      ! Finish

      return

   end function scale_matrix_

end module view_m

   
      

      
      

