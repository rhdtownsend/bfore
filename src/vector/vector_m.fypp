! Module  : vector_m
! Purpose : Define vector_t datatype, for representing vectors

#:include 'forum.inc'

module vector_m

   ! Uses

   use forum_m

   use transform_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Derived-type definitions

   type :: vector_t
      real(RD) :: x
      real(RD) :: y
      real(RD) :: z
   contains
      private
      procedure             :: equals_
      generic, public       :: operator(==) => equals_
      procedure             :: add_vector_vector_
      generic, public       :: operator(+) => add_vector_vector_
      procedure             :: neg_vector_
      procedure             :: sub_vector_vector_
      generic, public       :: operator(-) => neg_vector_, sub_vector_vector_
      procedure             :: mul_vector_scalar_
      procedure, pass(self) :: mul_scalar_vector_
      generic, public       :: operator(*) => mul_vector_scalar_, mul_scalar_vector_
      procedure             :: div_vector_scalar_
      generic, public       :: operator(/) => div_vector_scalar_
      procedure, public     :: image
   end type vector_t

   ! Interfaces

   ! In vector_operate_sm

   interface

      elemental module function equals_(self, other) result(equals)
         implicit none (type, external)
         class(vector_t), intent(in) :: self
         type(vector_t), intent(in)  :: other
         logical                     :: equals
      end function equals_

      elemental module function add_vector_vector_(self, other) result(vector)
         implicit none (type, external)
         class(vector_t), intent(in) :: self
         type(vector_t), intent(in)  :: other
         type(vector_t)              :: vector
      end function add_vector_vector_

      elemental module function sub_vector_vector_(self, other) result(vector)
         implicit none (type, external)
         class(vector_t), intent(in) :: self
         type(vector_t), intent(in)  :: other
         type(vector_t)              :: vector
      end function sub_vector_vector_

      elemental module function neg_vector_(self) result(vector)
         implicit none (type, external)
         class(vector_t), intent(in) :: self
         type(vector_t)              :: vector
      end function neg_vector_

      elemental module function mul_vector_scalar_(self, scalar) result(vector)
         implicit none (type, external)
         class(vector_t), intent(in) :: self
         real(RD), intent(in)        :: scalar
         type(vector_t)              :: vector
      end function mul_vector_scalar_

      elemental module function mul_scalar_vector_(scalar, self) result(vector)
         implicit none (type, external)
         real(RD), intent(in)        :: scalar
         class(vector_t), intent(in) :: self
         type(vector_t)              :: vector
      end function mul_scalar_vector_

      elemental module function div_vector_scalar_(self, scalar) result(vector)
         implicit none (type, external)
         class(vector_t), intent(in) :: self
         real(RD), intent(in)        :: scalar
         type(vector_t)              :: vector
      end function div_vector_scalar_

   end interface

   ! In vector_transform_sm

   interface

      impure elemental module function image(self, tform) result(vector)
         implicit none (type, external)
         class(vector_t), intent(in)   :: self
         type(transform_t), intent(in) :: tform
         type(vector_t)                :: vector
      end function image

   end interface

   ! In vector_array_sm

   interface to_array

      #:for rank in range(0, RANK_MAX)
         module subroutine to_array_${rank}$_(vectors, comps)
            implicit none (type, external)
            type(vector_t), intent(in) :: vectors${ARRAY_SPEC(rank)}$
            real(RD), intent(out)      :: comps${ARRAY_SPEC(rank+1)}$
         end subroutine to_array_${rank}$_
      #:endfor

   end interface to_array

   interface from_array

      #:for rank in range(0, RANK_MAX)
         module subroutine from_array_${rank}$_(comps, vectors)
            implicit none (type, external)
            real(RD), intent(in)        :: comps${ARRAY_SPEC(rank+1)}$
            type(vector_t), intent(out) :: vectors${ARRAY_SPEC(rank)}$
         end subroutine from_array_${rank}$_
      #:endfor

   end interface from_array

   interface reallocate
      module procedure reallocate_vector_t_2_
   end interface reallocate

   ! In this file

   interface norm2
      module procedure norm2_
   end interface norm2

   interface cross_product
      module procedure cross_product_
   end interface cross_product

   interface sum
      module procedure sum_
   end interface sum

   ! Accessibility

   private

   public :: vector_t
   public :: to_array
   public :: from_array
   public :: norm2
   public :: cross_product
   public :: sum
   public :: reallocate

contains

   elemental function norm2_(self)

      class(vector_t), intent(in) :: self
      real(RD)                    :: norm2_

      ! Evaluate the vector 2-norm

      norm2_ = NORM2([self%x, self%y, self%z])

      ! Finish

      return

   end function norm2_

   !****

   elemental function cross_product_(vector_a, vector_b) result(vector)

      type(vector_t), intent(in) :: vector_a
      type(vector_t), intent(in) :: vector_b
      type(vector_t)             :: vector

      ! Evaluate the vector cross-product

      vector%x = vector_a%y * vector_b%z - vector_a%z * vector_b%y
      vector%y = vector_a%z * vector_b%x - vector_a%x * vector_b%z
      vector%z = vector_a%x * vector_b%y - vector_a%y * vector_b%x

      ! Finish

      return

   end function cross_product_

   !****

   pure function sum_(vectors) result(vector)

      type(vector_t), intent(in) :: vectors(:)
      type(vector_t)             :: vector

      ! Evaluate the sum of the vectors

      vector%x = SUM(vectors%x)
      vector%y = SUM(vectors%y)
      vector%z = SUM(vectors%z)

      ! Finish

      return

   end function sum_

   !****

   $:REALLOCATE('type(vector_t)', 'vector_t', 2)

end module vector_m
