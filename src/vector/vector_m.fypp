! Module  : vector_m
! Purpose : Define vector_t datatype, for representing vectors

#:include 'forum.inc'

module vector_m

   ! Uses

   use forum_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Derived-type definitions

   type :: vector_t
      real(RD) :: x
      real(RD) :: y
      real(RD) :: z
   contains
      private
      procedure             :: equals_
      generic, public       :: operator(==) => equals_
      procedure             :: add_vector_vector_
      generic, public       :: operator(+) => add_vector_vector_
      procedure             :: sub_vector_vector_
      generic, public       :: operator(-) => sub_vector_vector_
      procedure             :: mul_vector_scalar_
      procedure, pass(self) :: mul_scalar_vector_
      generic, public       :: operator(*) => mul_vector_scalar_, mul_scalar_vector_
      procedure             :: div_vector_scalar_
      generic, public       :: operator(/) => div_vector_scalar_
      procedure, public     :: image
   end type vector_t

   ! Interfaces

   interface

      ! In vector_operate_sm

      elemental module function equals_(self, other) result(equals)
         implicit none (type, external)
         class(vector_t), intent(in) :: self
         type(vector_t), intent(in)  :: other
         logical                     :: equals
      end function equals_

      elemental module function add_vector_vector_(self, other) result(vector)
         implicit none (type, external)
         class(vector_t), intent(in) :: self
         type(vector_t), intent(in)  :: other
         type(vector_t)              :: vector
      end function add_vector_vector_

      elemental module function sub_vector_vector_(self, other) result(vector)
         implicit none (type, external)
         class(vector_t), intent(in) :: self
         type(vector_t), intent(in)  :: other
         type(vector_t)              :: vector
      end function sub_vector_vector_

      elemental module function mul_vector_scalar_(self, scalar) result(vector)
         implicit none (type, external)
         class(vector_t), intent(in) :: self
         real(RD), intent(in)        :: scalar
         type(vector_t)              :: vector
      end function mul_vector_scalar_

      elemental module function mul_scalar_vector_(scalar, self) result(vector)
         implicit none (type, external)
         real(RD), intent(in)        :: scalar
         class(vector_t), intent(in) :: self
         type(vector_t)              :: vector
      end function mul_scalar_vector_

      elemental module function div_vector_scalar_(self, scalar) result(vector)
         implicit none (type, external)
         class(vector_t), intent(in) :: self
         real(RD), intent(in)        :: scalar
         type(vector_t)              :: vector
      end function div_vector_scalar_

      ! In vector_transform_sm

      impure elemental module function image(self, tform) result(vector)
         use transform_m
         implicit none (type, external)
         class(vector_t), intent(in)   :: self
         type(transform_t), intent(in) :: tform
         type(vector_t)                :: vector
      end function image

   end interface

   interface norm2
      module procedure norm2_
   end interface norm2

   interface cross_product
      module procedure cross_product_
   end interface cross_product

   interface sum
      module procedure sum_
   end interface sum

   interface to_array
      #:for rank in range(1, RANK_MAX)
         module procedure to_array_${rank}$_
      #:endfor
   end interface to_array

   interface from_array
      #:for rank in range(1, RANK_MAX)
         module procedure from_array_${rank}$_
      #:endfor
   end interface from_array

   interface reallocate
      module procedure reallocate_vector_t_2_
   end interface reallocate

   ! Accessibility

   private

   public :: vector_t
   public :: norm2
   public :: cross_product
   public :: sum
   public :: to_array
   public :: from_array
   public :: reallocate

contains

   elemental function norm2_(self)

      class(vector_t), intent(in) :: self
      real(RD)                    :: norm2_

      ! Evaluate the vector 2-norm

      norm2_ = NORM2([self%x, self%y, self%z])

      ! Finish

      return

   end function norm2_

   !****

   elemental function cross_product_(vector_a, vector_b) result(vector)

      type(vector_t), intent(in) :: vector_a
      type(vector_t), intent(in) :: vector_b
      type(vector_t)             :: vector

      ! Evaluate the vector cross-product

      vector%x = vector_a%y * vector_b%z - vector_a%z * vector_b%y
      vector%y = vector_a%z * vector_b%x - vector_a%x * vector_b%z
      vector%z = vector_a%x * vector_b%y - vector_a%y * vector_b%x

      ! Finish

      return

   end function cross_product_

   !****

   pure function sum_(vectors) result(vector)

      type(vector_t), intent(in) :: vectors(:)
      type(vector_t)             :: vector

      ! Evaluate the sum of the vectors

      vector%x = SUM(vectors%x)
      vector%y = SUM(vectors%y)
      vector%z = SUM(vectors%z)

      ! Finish

      return

   end function sum_

   !****

   #:for rank in range(1, RANK_MAX)

      subroutine to_array_${rank}$_(vectors, comps)

         type(vector_t), intent(in)         :: vectors${ARRAY_SPEC(rank)}$
         real(RD), allocatable, intent(out) :: comps${ARRAY_SPEC(rank+1)}$

         integer :: shape_vectors(${rank}$)
         integer :: shape_comps(${rank+1}$)

         ! Convert the array of vectors into an (3,...) array of vector components

         shape_vectors = SHAPE(vectors)
         shape_comps = [3, shape_vectors]

         comps = RESHAPE( &
            TRANSFER(vectors, MOLD=0._RD, SIZE=PRODUCT(shape_comps)), &
            SHAPE=shape_comps)

         ! Finish

         return

      end subroutine to_array_${rank}$_

      !****

      subroutine from_array_${rank}$_(comps, vectors)

         real(RD), intent(in)                     :: comps${ARRAY_SPEC(rank+1)}$
         type(vector_t), allocatable, intent(out) :: vectors${ARRAY_SPEC(rank)}$

         integer :: shape_comps(${rank+1}$)
         integer :: shape_vectors(${rank}$)

         @:CHECK_BOUNDS(SIZE(comps, 1), 3)

         ! Convert the (3,...)  array of vector components into an array of vectors

         shape_comps = SHAPE(comps)
         shape_vectors = shape_comps(2:)

         vectors = RESHAPE( &
            TRANSFER(comps, MOLD=vector_t(0._RD, 0._RD, 0._RD), SIZE=PRODUCT(shape_vectors)), &
            SHAPE=shape_vectors)

         ! Finish

         return

      end subroutine from_array_${rank}$_

   #:endfor

   !****

   $:REALLOCATE('type(vector_t)', 'vector_t', 2)

end module vector_m
