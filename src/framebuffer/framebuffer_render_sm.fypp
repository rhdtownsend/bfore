! Submodule : framebuffer_m
! Purpose   : Rendering routines for framebuffer_t

#:include 'forum.inc'

submodule (framebuffer_m) framebuffer_render_sm

   ! Uses

   use transform_m
   use point_m
   use vector_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Procedures

contains

   module procedure render

      type(transform_t) :: tform_camera
      type(transform_t) :: tform_pixel
      integer           :: v
      type(point_t)     :: P(mesh%n_vert)
      integer           :: f
      type(vector_t)    :: A
      integer           :: f_e
      integer           :: v1
      integer           :: v2
      integer           :: v3

      ! Set up transformations

      tform_camera = view%camera_transform()
      tform_pixel = view%pixel_transform(self%n_x, self%n_y)

      ! Extract vertex points from the mesh, and transform to the
      ! pixel system

      vert_loop: do v = 1, mesh%n_vert
         P(v) = mesh%vert_point(v)
      end do vert_loop

      P = P%image(tform_pixel)

      ! Loop through faces of mesh, rendering each one

      face_loop: do f = 1, mesh%n_face

         ! Get the face area vector, and transform to the camera
         ! system

         A = mesh%face_area(f)
         A = A%image(tform_camera)

         ! Check for a forward-facing triangle

         if (A%z > 0._RD) then

            ! Render the face

            f_e = mesh%face_edge(f)

            v1 = mesh%edge_vert(f_e)
            v2 = mesh%edge_vert(mesh%edge_next(f_e))
            v3 = mesh%edge_vert(mesh%edge_prev(f_e))

            call render_triangle(self, P([v1, v2, v3]), process_pixel, f)

         end if

      end do face_loop

      ! Finish

      return

   end procedure render

   !****

   module procedure render_triangle

      integer  :: i_x_min
      integer  :: i_x_max
      integer  :: i_y_min
      integer  :: i_y_max
      real(RD) :: area2
      real(RD) :: inv_area2
      real(RD) :: EF_a(3)
      real(RD) :: EF_b(3)
      real(RD) :: EF_c(3)
      logical  :: EF_tie(3)
      integer  :: i_x
      integer  :: i_y
      logical  :: any_inside
      real(RD) :: EF(3)
      logical  :: inside
      real(RD) :: lambda(3)
      real(RD) :: z

      @:CHECK_BOUNDS(SIZE(P), 3)

      ! Render a triangle with vertex points P(:,:) (in the
      ! framebuffer system). The algorithm largely follows that
      ! described by Pineda (1988). If process_pixel is present,
      ! it is used to process the pixel (like a fragment shader);
      ! then, origin must also be present

      ! Determine the pixel bounding box

      i_x_min = MAX(FLOOR(MINVAL(P%x)), 1)
      i_x_max = MIN(CEILING(MAXVAL(P%x)), self%n_x)

      i_y_min = MAX(FLOOR(MINVAL(P%y)), 1)
      i_y_max = MIN(CEILING(MAXVAL(P%y)), self%n_y)

      ! Check if the bounding box is null

      if (i_x_min > i_x_max .OR. i_y_min > i_y_max) return

      ! Calculate quantities used in edge-function evaluation

      !EF_a = P(2,[2, 3, 1]) - P(2,[3, 1, 2])
      !EF_b = P(1,[3, 1, 2]) - P(1,[2, 3, 1])
      !EF_c = P(1,[2, 3, 1])*P(2,[3, 1, 2]) - P(1,[3, 1, 2])*P(2,[2, 3, 1])

      EF_a = P([2, 3, 1])%y - P([3, 1, 2])%y
      EF_b = P([3, 1, 2])%x - P([2, 3, 1])%x
      EF_c = P([2, 3, 1])%x*P([3, 1, 2])%y - P([3, 1, 2])%x*P([2, 3, 1])%y

      ! Calculate (twice) the projected area of the triangle,
      ! returning if it is small (indicating an edge-on triangle)

      area2 = SUM(EF_c)

      if (ABS(area2) < EPSILON(0._RD)) return

      inv_area2 = 1._RD/area2

      ! Calculate the tie-breaker function, based on Fig. 2 of McCool,
      ! Wales & Moule (2002), modified to follow the OpenGL fill-rule
      ! convention that top/left edges are drawn

      EF_tie = EF_a > 0._RD .OR. (EF_a == 0._RD .AND. EF_b < 0._RD)

      ! Loop through the pixels within the bounding box

      y_loop: do i_y = i_y_min, i_y_max

         any_inside = .FALSE.

         x_loop: do i_x = i_x_min, i_x_max

            ! Evaluate the edge functions

            EF = i_x*EF_a + i_y*EF_b + EF_c

            ! Determine if the pixel lies within the triangle

            inside = ALL(EF > 0._RD .OR. (EF == 0._RD .AND. EF_tie))

            if (inside) then

               ! Evaluate normalized barycentric coordinates

               lambda = inv_area2*EF

               ! Perform the depth test

               z = DOT_PRODUCT(lambda, P%z)

               if (z > self%PZ(i_x,i_y)) then

                  ! Store the depth

                  self%PZ(i_x,i_y) = z

                  ! Process the pixel

                  if (PRESENT(process_pixel) .AND. PRESENT(origin)) then
                     call process_pixel(i_x, i_y, lambda, origin)
                  end if

                  ! Flag that at least one pixel on this scanline was
                  ! inside

                  any_inside = .TRUE.

               end if

            else

               ! Check if the scaline is done

               if (any_inside) exit x_loop

            end if

         end do x_loop
      end do y_loop

      ! Finish

      return

   end procedure render_triangle

end submodule framebuffer_render_sm
