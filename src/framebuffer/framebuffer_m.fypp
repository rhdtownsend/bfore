! Module  : framebuffer_m
! Purpose : Define framebuffer_t datatype, for representing a framebuffer
!           for rasterizing geo_mesh_t meshes

#:include 'forum.inc'

module framebuffer_m

   ! Uses

   use forum_m

   use geo_mesh_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Parameters

   integer, parameter :: NULL_TAG = -HUGE(0)

   ! Derived-type definitions

   type :: framebuffer_t
      private
      real(RD), allocatable :: PD(:,:)   ! Pixel depth buffer
      real(RD), allocatable :: PA(:,:,:) ! Pixel attrubte buffer
      integer, allocatable  :: PT(:,:)   ! Pixel tag buffer
      integer, public       :: n_pix_x
      integer, public       :: n_pix_y
      integer, public       :: n_attr
   contains
      private
      procedure, public :: read
      procedure, public :: write
   end type framebuffer_t

   ! Interfaces

   interface framebuffer_t
      module procedure frambuffer_t_
   end interface framebuffer_t

   ! Accessibility

   private

   public :: framebuffer_t

   ! Procedures

contains

   function framebuffer_t_(n_x, n_y, n_attr, view) result(fbuff)

      integer, intent(in)      :: n_x
      integer, intent(in)      :: n_y
      integer, intent(in)      :: n_attr
      type(view_t), intent(in) :: view
      type(framebuffer_t)      :: fbuff

      ! Construct the framebuffer_t

      allocate(fbuff%PD(n_x, n_y)
      allocate(fbuff%PA(n_attr, n_x, n_y)
      allocate(fbuff%PT(n_x, n_y)

      fbuff%PA = 0._RD
      fbuff%PA = 0._RD
      fbuff%PT = NULL_TAG

      fbuff%n_x = n_x
      fbuff%n_y = n_y
      fbuff%n_attr = n_attr
      
      ! Finish

      return

   end function framebuffer_t_

   !****

   subroutine render(self, mesh, view, tag, shader)

      class(framebuffer_t), intent(inout) :: fbuff
      class(geo_mesh_t), intent(in)       :: mesh
      class(view_t), intent(in)           :: view
      integer, intent(in)                 :: tag
      interface
         subroutine shade_pixel(f, alpha, beta, gamma, attrs)
            integer, intent(in)   :: f
            real(RD), intent(in)  :: alpha
            real(RD), intent(in)  :: beta
            real(RD), intent(in)  :: gamma
            real(RD), intent(out) :: attrs(:)
         end subroutine shader
      end interface

      ! Loop through faces, rendering each one into the framebuffer_t

      face_loop: do f = 1, mesh%n_face

         ! Get the face orientation

         S = mesh%face_vect_area(f)

         S = transform_to_window(S)

         ! Check for visibility

         if (S(3) > 0._RD) then

            ! Render the face

            call render_face_(c1, c2, c3)

         end if

      end do face_loop

      ! Finish

      return

   end subroutine render

   !****

   subroutine render_face(self, mesh, view, tag, shader, f)

      

   end subroutine render_face

end module framebuffer_m
