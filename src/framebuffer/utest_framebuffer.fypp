! Program : utest_framebuffer
! Purpose : Unit tests for framebuffer_m

#:include 'forum.inc'
#:include 'utest.inc'

program utest_framebuffer

   ! Uses

   use forum_m

   use mesh_m
   use mesh_primitives_m
   use framebuffer_m
   use view_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Parameter definitions

   real(RD), parameter :: Z_MIN = -HUGE(0._RD)

   ! Run the tests

   call test_triangle()
   call test_construction()
   call test_fill_rules()
   call test_io()

   ! Finish

contains

   subroutine test_triangle()

      type(framebuffer_t)   :: fbuff
      real(RD), allocatable :: z(:,:)

      print *, 'Checking framebuffer triangle rendering'

      fbuff = framebuffer_t(3, 3)

      call render_tri(fbuff, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 0._RD, 'BR')
      call render_tri(fbuff, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 0._RD, 'TL')
      z = RESHAPE([ &
         0._RD, 0._RD, 0._RD, &
         0._RD, 0._RD, 0._RD, &
         0._RD, 0._RD, 0._RD], &
         SHAPE=[3,3])
      @:CHECK(check_depths(fbuff, z), 'two triangles making a square')

      ! Finish

      return

   end subroutine test_triangle


   !****

   subroutine test_construction()

      type(framebuffer_t)   :: fbuff_a
      type(framebuffer_t)   :: fbuff_b
      type(framebuffer_t)   :: fbuff
      real(RD), allocatable :: z(:,:)

      print *, 'Checking framebuffer construction'

      fbuff_a = framebuffer_t(3, 3)
      call render_tri(fbuff_a, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 0._RD, 'BR')

      fbuff_b = framebuffer_t(3, 3)
      call render_tri(fbuff_b, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 1._RD, 'BL')

      fbuff = framebuffer_t([fbuff_a, fbuff_b])

      z = RESHAPE([ &
         1._RD, 1._RD, 0._RD, &
         1._RD, 0._RD, 0._RD, &
         Z_MIN, Z_MIN, 0._RD], &
         SHAPE=[3,3])
      @:CHECK(check_depths(fbuff, z), 'merge two triangle framebuffers')

      ! Finish

      return

   end subroutine test_construction

   !****

   subroutine test_fill_rules()

      type(framebuffer_t)   :: fbuff
      real(RD), allocatable :: z(:,:)

      ! Test fill rules (see
      ! https://learn.microsoft.com/en-us/windows/win32/direct3d9/rasterization-rules)

      print *, 'Checking framebuffer fill rules'

      fbuff = framebuffer_t(3, 3)
      call render_tri(fbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'L')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         0._RD, 0._RD, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(fbuff, z), 'left triangle')

      !

      fbuff = framebuffer_t(3, 3)
      call render_tri(fbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'B')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(fbuff, z), 'bot triangle')

      !

      fbuff = framebuffer_t(3, 3)
      call render_tri(fbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'T')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         0._RD, 0._RD, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(fbuff, z), 'top triangle')

      !

      fbuff = framebuffer_t(3, 3)
      call render_tri(fbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'TL')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         0._RD, Z_MIN, Z_MIN, &
         0._RD, 0._RD, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(fbuff, z), 'top-left triangle')

      !

      fbuff = framebuffer_t(3, 3)
      call render_tri(fbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'BL')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         0._RD, Z_MIN, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(fbuff, z), 'bot-left triangle')

      !

      fbuff = framebuffer_t(3, 3)
      call render_tri(fbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'BR')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(fbuff, z), 'bot-right triangle')

      !

      fbuff = framebuffer_t(3, 3)
      call render_tri(fbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'TR')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         0._RD, 0._RD, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(fbuff, z), 'top-right triangle')

      ! Finish

      return

   end subroutine test_fill_rules

   !****

   subroutine test_io()

      type(mesh_t)        :: mesh
      type(view_t)        :: view
      type(framebuffer_t) :: fbuff_out
      type(framebuffer_t) :: fbuff_in
      type(hdf5io_t)      :: hdf5io
      integer             :: stat

      ! Test rendering operations

      print *,'Checking framebuffer i/o'

      mesh = sphere_mesh(2)

      view = view_t(0._RD*DEG_TO_RAD, 0._RD*DEG_TO_RAD, 0._RD, &
         [0._RD, 0._RD, 0._RD], &
         2.4_RD, 2.4_RD)

      fbuff_out = framebuffer_t(1024, 1024)
      call fbuff_out%render(mesh, view)

      hdf5io = hdf5io_t('utest_framebuffer.h5', CREATE_FILE)
      call fbuff_out%write(hdf5io, stat)
      call hdf5io%final()
      @:CHECK(stat == STAT_OK, 'write framebuffer to file')

      hdf5io = hdf5io_t('utest_framebuffer.h5', OPEN_FILE_RO)
      call fbuff_in%read(hdf5io, stat)
      call hdf5io%final()
      @:CHECK(stat == STAT_OK, 'read framebuffer from file')

      @:CHECK(compare(fbuff_out, fbuff_in), 'read framebuffer equals written framebuffer')

      ! Finish

      return

   end subroutine test_io

   !****

   subroutine render_tri(fbuff, x_min, x_max, y_min, y_max, z, orient)

      type(framebuffer_t)      :: fbuff
      real(RD), intent(in)     :: x_min
      real(RD), intent(in)     :: x_max
      real(RD), intent(in)     :: y_min
      real(RD), intent(in)     :: y_max
      real(RD), intent(in)     :: z
      character(*), intent(in) :: orient

      real(RD) :: x_mid
      real(RD) :: y_mid
      real(RD) :: rect_points(3,9)

      ! Render a triangle within the supplid bounding box

      x_mid = 0.5_RD*(x_min + x_max)
      y_mid = 0.5_RD*(y_min + y_max)

      rect_points = RESHAPE([ &
         x_min, y_min, z, &
         x_mid, y_min, z, &
         x_max, y_min, z, &
         x_min, y_mid, z, &
         x_mid, y_mid, z, &
         x_max, y_mid, z, &
         x_min, y_max, z, &
         x_mid, y_max, z, &
         x_max, y_max, z], &
         SHAPE=[3, 9])

      select case(orient)
      case('L')
         call fbuff%render_triangle(rect_points(:,[7, 1, 6]))
      case('B')
         call fbuff%render_triangle(rect_points(:,[1, 3, 8]))
      case('R')
         call fbuff%render_triangle(rect_points(:,[3, 9, 4]))
      case('T')
         call fbuff%render_triangle(rect_points(:,[9, 7, 2]))
      case('TL')
         call fbuff%render_triangle(rect_points(:,[7, 1, 9]))
      case('BL')
         call fbuff%render_triangle(rect_points(:,[1, 3, 7]))
      case('BR')
         call fbuff%render_triangle(rect_points(:,[3, 9, 1]))
      case('TR')
         call fbuff%render_triangle(rect_points(:,[9, 7, 3]))
      case default
         @:ABORT('invalid orient')
      end select

      ! Finish

      return

   end subroutine render_tri

   !****

   function check_depths(fbuff, z) result(same)

      real(RD), parameter :: TOL = 1E-15_RD

      type(framebuffer_t), intent(in) :: fbuff
      real(RD), intent(in)            :: z(:,:)
      logical                         :: same

      integer  :: i_x
      integer  :: i_y
      real(RD) :: fbuff_z(fbuff%n_x,fbuff%n_y)

      ! Check the framebuffer depth buffer

      do i_y = 1, fbuff%n_y
         do i_x = 1, fbuff%n_x
            fbuff_z(i_x,i_y) = fbuff%pixel_depth(i_x, i_y)
         end do
      end do

      same = ALL(ABS(fbuff_z - z) < TOL)

      ! Finish

      return

   end function check_depths

end program utest_framebuffer
