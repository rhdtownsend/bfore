! Submodule : map_m
! Purpose   : Rendering routines for map_t

#:include 'forum.inc'

submodule (map_m) map_render_sm

   ! Uses

   use framebuffer_m
   use transform_m
   use vector_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Procedures

contains

   module procedure render

      type(transform_t)   :: tform_camera
      integer             :: v
      type(vector_t)      :: vert_vectors_c(self%n_v,mesh%n_vert)
      type(framebuffer_t) :: fbuff
      integer             :: i_a

      integer :: start, end, count

      @:CHECK_BOUNDS(SIZE(vert_scalars, 1), self%n_s)
      @:CHECK_BOUNDS(SIZE(vert_scalars, 2), mesh%n_vert)

      @:CHECK_BOUNDS(SIZE(vert_vectors, 1), self%n_v)
      @:CHECK_BOUNDS(SIZE(vert_vectors, 2), mesh%n_vert)

      ! Set up transformations

      tform_camera = view%camera_transform()

      ! Evalaute vert_vectors in the camera frame

      vert_vectors_c = vert_vectors%image(tform_camera)

      ! Initialize the framebuffer

      fbuff = framebuffer_t(self%n_x, self%n_y)

      ! Render the mesh into the framebuffer

      call system_clock(start, count)

      call fbuff%render(mesh, view, process_pixel_)

      call system_clock(end)

      print *,'render:', REAL(end-start, RD)/count

      ! Finish

      return

   contains

      subroutine process_pixel_(i_x, i_y, lambda, origin)

         integer, intent(in)  :: i_x
         integer, intent(in)  :: i_y
         real(RD), intent(in) :: lambda(3)
         integer, intent(in)  :: origin

         integer :: f_e
         integer :: v1
         integer :: v2
         integer :: v3
         integer :: i_a

         ! Determine the origin vertices

         f_e = mesh%face_edge(origin)

         v1 = mesh%edge_vert(f_e)
         v2 = mesh%edge_vert(mesh%edge_next(f_e))
         v3 = mesh%edge_vert(mesh%edge_prev(f_e))

         ! Update the attributes

         do i_a = 1, self%n_s
            self%PS(i_a,i_x,i_y) = SUM(vert_scalars(i_a,[v1, v2, v3])*lambda)
         end do

         do i_a = 1, self%n_v
            self%PV(i_a,i_x,i_y) = affine_sum(vert_vectors_c(i_a,[v1,v2,v3]), lambda)
         end do

         ! Finish

         return

      end subroutine process_pixel_

   end procedure render

end submodule map_render_sm
