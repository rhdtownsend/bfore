! Program : utest_renderbuff
! Purpose : Unit tests for renderbuff_m

#:include 'forum.inc'
#:include 'utest.inc'

program utest_renderbuff

   ! Uses

   use forum_m

   use mesh_m
   use mesh_primitives_m
   use point_m
   use renderbuff_m
   use view_m
   use vector_m
   use stat_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Parameter definitions

   real(RD), parameter :: Z_MIN = -HUGE(0._RD)

   ! Run the tests

   call test_triangle()
   call test_construction()
   call test_fill_rules()
   call test_io()

   ! Finish

contains

   subroutine test_triangle()

      type(renderbuff_t)    :: rbuff
      real(RD), allocatable :: z(:,:)

      rbuff = renderbuff_t(3, 3)

      call render_tri(rbuff, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 0._RD, 'BR')
      call render_tri(rbuff, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 0._RD, 'TL')
      z = RESHAPE([ &
         0._RD, 0._RD, 0._RD, &
         0._RD, 0._RD, 0._RD, &
         0._RD, 0._RD, 0._RD], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'two triangles making a square')

      ! Finish

      return

   end subroutine test_triangle


   !****

   subroutine test_construction()

      type(renderbuff_t)    :: rbuff_a
      type(renderbuff_t)    :: rbuff_b
      type(renderbuff_t)    :: rbuff
      real(RD), allocatable :: z(:,:)

      print *, 'Checking renderbuff construction'

      rbuff_a = renderbuff_t(3, 3)
      call render_tri(rbuff_a, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 0._RD, 'BR')

      rbuff_b = renderbuff_t(3, 3)
      call render_tri(rbuff_b, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 1._RD, 'BL')

      rbuff = renderbuff_t([rbuff_a, rbuff_b])

      z = RESHAPE([ &
         1._RD, 1._RD, 0._RD, &
         1._RD, 0._RD, 0._RD, &
         Z_MIN, Z_MIN, 0._RD], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'merge two triangle renderbuffs')

      ! Finish

      return

   end subroutine test_construction

   !****

   subroutine test_fill_rules()

      type(renderbuff_t)    :: rbuff
      real(RD), allocatable :: z(:,:)

      ! Test fill rules (see
      ! https://learn.microsoft.com/en-us/windows/win32/direct3d9/rasterization-rules)

      print *, 'Checking renderbuff fill rules'

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'L')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         0._RD, 0._RD, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'left triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'B')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'bot triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'T')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         0._RD, 0._RD, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'top triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'TL')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         0._RD, Z_MIN, Z_MIN, &
         0._RD, 0._RD, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'top-left triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'BL')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         0._RD, Z_MIN, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'bot-left triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'BR')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'bot-right triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'TR')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         0._RD, 0._RD, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'top-right triangle')

      ! Finish

      return

   end subroutine test_fill_rules

   !****

   subroutine test_io()

      type(mesh_t)           :: mesh
      integer                :: v
      type(point_t), pointer :: point
      type(view_t)           :: view
      type(renderbuff_t)     :: rbuff_out
      type(renderbuff_t)     :: rbuff_in
      type(hdf5io_t)         :: hdf5io
      integer                :: stat

      ! Test rendering operations

      print *,'Checking renderbuff i/o'

      mesh = sphere_mesh(1._RD, 6, 3, 1)

      do v = 1, mesh%n_vert

         point => mesh%vert_point(v)

         mesh%vert_scalar(1,v) = point%x
         mesh%vert_scalar(2,v) = point%y
         mesh%vert_scalar(3,v) = point%z

         mesh%vert_vector(1,v) = point - point_t(0._RD, 0._RD, 0._RD)

      end do

      view = view_t(0._RD*DEG_TO_RAD, 0._RD*DEG_TO_RAD, 0._RD, &
         [0._RD, 0._RD, 0._RD], &
         2.4_RD, 2.4_RD)

      rbuff_out = renderbuff_t(8192, 8192, 3, 1)
      call rbuff_out%render(mesh, view)

      hdf5io = hdf5io_t('utest_renderbuff.h5', CREATE_FILE)
      call rbuff_out%write(hdf5io, stat)
      call hdf5io%final()
      @:CHECK(stat == STAT_OK, 'write renderbuff to file')

      hdf5io = hdf5io_t('utest_renderbuff.h5', OPEN_FILE_RO)
      call rbuff_in%read(hdf5io, stat)
      call hdf5io%final()
      @:CHECK(stat == STAT_OK, 'read renderbuff from file')

      @:CHECK(rbuff_out == rbuff_in, 'read renderbuff equals written renderbuff')

      ! Finish

      return

   end subroutine test_io

   !****

   subroutine render_tri(rbuff, x_min, x_max, y_min, y_max, z, orient)

      type(renderbuff_t)       :: rbuff
      real(RD), intent(in)     :: x_min
      real(RD), intent(in)     :: x_max
      real(RD), intent(in)     :: y_min
      real(RD), intent(in)     :: y_max
      real(RD), intent(in)     :: z
      character(*), intent(in) :: orient

      real(RD)                    :: x_mid
      real(RD)                    :: y_mid
      type(point_t)               :: rect_points(9)
      real(RD), allocatable       :: rect_scalars(:,:)
      type(vector_t), allocatable :: rect_vectors(:,:)

      ! Render a triangle within the supplid bounding box

      x_mid = 0.5_RD*(x_min + x_max)
      y_mid = 0.5_RD*(y_min + y_max)

      call from_array(RESHAPE([ &
         x_min, y_min, z, &
         x_mid, y_min, z, &
         x_max, y_min, z, &
         x_min, y_mid, z, &
         x_mid, y_mid, z, &
         x_max, y_mid, z, &
         x_min, y_max, z, &
         x_mid, y_max, z, &
         x_max, y_max, z], &
         SHAPE=[3, 9]), rect_points)

      allocate(rect_scalars(rbuff%n_scalar,3))
      rect_scalars = 0._RD

      allocate(rect_vectors(rbuff%n_vector,3))
      rect_vectors = vector_t(0._RD, 0._RD, 0._RD)

      select case(orient)
      case('L')
         call rbuff%render_triangle(rect_points([7, 1, 6]), rect_scalars, rect_vectors)
      case('B')
         call rbuff%render_triangle(rect_points([1, 3, 8]), rect_scalars, rect_vectors)
      case('R')
         call rbuff%render_triangle(rect_points([3, 9, 4]), rect_scalars, rect_vectors)
      case('T')
         call rbuff%render_triangle(rect_points([9, 7, 2]), rect_scalars, rect_vectors)
      case('TL')
         call rbuff%render_triangle(rect_points([7, 1, 9]), rect_scalars, rect_vectors)
      case('BL')
         call rbuff%render_triangle(rect_points([1, 3, 7]), rect_scalars, rect_vectors)
      case('BR')
         call rbuff%render_triangle(rect_points([3, 9, 1]), rect_scalars, rect_vectors)
      case('TR')
         call rbuff%render_triangle(rect_points([9, 7, 3]), rect_scalars, rect_vectors)
      case default
         @:ABORT('invalid orient')
      end select

      ! Finish

      return

   end subroutine render_tri

   !****

   function check_depths(rbuff, z) result(same)

      real(RD), parameter :: TOL = 1E-15_RD

      type(renderbuff_t), intent(in) :: rbuff
      real(RD), intent(in)           :: z(:,:)
      logical                        :: same

      integer  :: i_x
      integer  :: i_y
      real(RD) :: rbuff_z(rbuff%n_x,rbuff%n_y)

      ! Check the renderbuff depth buffer

      do i_y = 1, rbuff%n_y
         do i_x = 1, rbuff%n_x
            rbuff_z(i_x,i_y) = rbuff%pixel_depth(i_x, i_y)
         end do
      end do

      same = ALL(ABS(rbuff_z - z) < TOL)

      ! Finish

      return

   end function check_depths

end program utest_renderbuff
