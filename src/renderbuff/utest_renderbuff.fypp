! Program : utest_renderbuff
! Purpose : Unit tests for renderbuff_m

#:include 'forum.inc'
#:include 'utest.inc'

program utest_renderbuff

   ! Uses

   use forum_m

   use mesh_m
   use mesh_primitives_m
   use point_m
   use renderbuff_m
   use sphere_surface_m
   use stat_m
   use view_m
   use vector_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Parameter definitions

   real(RD), parameter :: Z_MIN = -HUGE(0._RD)

   ! Run the tests

   call test_triangle()
   call test_construction()
   call test_io()

   ! Finish

contains

   subroutine test_triangle()

      type(renderbuff_t)    :: rbuff
      real(RD), allocatable :: z(:,:)

      print *,'Checking renderbuff triangle rendering'

      ! Fill-rule tests from
      ! https://learn.microsoft.com/en-us/windows/win32/direct3d9/rasterization-rules

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'L')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         0._RD, 0._RD, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'fill rules for edge-left triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'B')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'fill rules for edge-bot triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'T')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         0._RD, 0._RD, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'fill rules for edge-top triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'TL')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         0._RD, Z_MIN, Z_MIN, &
         0._RD, 0._RD, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'fill rules for corner-top-left triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'BL')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         0._RD, Z_MIN, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'fill rules for corner-bot-left triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'BR')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         Z_MIN, Z_MIN, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'fill rules for corner-bot-right triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_tri(rbuff, 1._RD, 3._RD, 1._RD, 3._RD, 0._RD, 'TR')
      z = RESHAPE([ &
         Z_MIN, Z_MIN, Z_MIN, &
         Z_MIN, 0._RD, Z_MIN, &
         0._RD, 0._RD, Z_MIN], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'full rules for corner-top-right triangle')

      !

      rbuff = renderbuff_t(3, 3)
      call render_square(rbuff, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 0._RD)
      z = RESHAPE([ &
         0._RD, 0._RD, 0._RD, &
         0._RD, 0._RD, 0._RD, &
         0._RD, 0._RD, 0._RD], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'square from two triangles')

      !

      rbuff = renderbuff_t(3, 3, n_scalar=2)
      call render_square(rbuff, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 0._RD)
      @:CHECK(check_scalars(rbuff), 'square w/ two scalars')

      !

      rbuff = renderbuff_t(3, 3, n_vector=2)
      call render_square(rbuff, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 0._RD)
      @:CHECK(check_vectors(rbuff), 'square w/ two vectors')

      !

      rbuff = renderbuff_t(3, 3, n_scalar=2, n_vector=1)
      call render_square(rbuff, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 0._RD)
      @:CHECK(check_scalars(rbuff) .AND. check_vectors(rbuff), 'square w/ two scalars and one vector')

      ! Finish

      return

   end subroutine test_triangle


   !****

   subroutine test_construction()

      type(renderbuff_t)    :: rbuff_a
      type(renderbuff_t)    :: rbuff_b
      type(renderbuff_t)    :: rbuff
      real(RD), allocatable :: z(:,:)

      print *, 'Checking renderbuff construction'

      rbuff_a = renderbuff_t(3, 3)
      call render_tri(rbuff_a, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 0._RD, 'BR')

      rbuff_b = renderbuff_t(3, 3)
      call render_tri(rbuff_b, 0.5_RD, 3.5_RD, 0.5_RD, 3.5_RD, 1._RD, 'BL')

      rbuff = renderbuff_t([rbuff_a, rbuff_b])

      z = RESHAPE([ &
         1._RD, 1._RD, 0._RD, &
         1._RD, 0._RD, 0._RD, &
         Z_MIN, Z_MIN, 0._RD], &
         SHAPE=[3,3])
      @:CHECK(check_depths(rbuff, z), 'merge two triangle renderbuffs')

      ! Finish

      return

   end subroutine test_construction

   !****

   subroutine test_io()

      type(mesh_t)           :: mesh
      integer                :: v
      type(point_t), pointer :: point
      type(view_t)           :: view
      type(renderbuff_t)     :: rbuff_out
      type(renderbuff_t)     :: rbuff_in
      type(hdf5io_t)         :: hdf5io
      integer                :: stat

      print *,'Checking renderbuff i/o'

      mesh = polar_mesh(sphere_surface_t(1._RD), 0, 1, 1)

      do v = 1, mesh%n_vert

         mesh%vert_scalar(1,v) = 1._RD
         mesh%vert_vector(1,v) = vector_t(1._RD, 1._RD, 1._RD)

      end do

      view = view_t(point_t(0._RD, 0._RD, 0._RD), &
         0._RD*DEG_TO_RAD, 0._RD*DEG_TO_RAD, 0._RD*DEG_TO_RAD, &
         2.4_RD, 2.4_RD)

      rbuff_out = renderbuff_t(256, 256, 1, 1)
      call rbuff_out%render(mesh, view)

      hdf5io = hdf5io_t('utest_renderbuff.h5', CREATE_FILE)
      call rbuff_out%write(hdf5io, stat)
      call hdf5io%final()
      @:CHECK(stat == STAT_OK, 'write renderbuff to file')

      hdf5io = hdf5io_t('utest_renderbuff.h5', OPEN_FILE_RO)
      call rbuff_in%read(hdf5io, stat)
      call hdf5io%final()
      @:CHECK(stat == STAT_OK, 'read renderbuff from file')

      @:CHECK(rbuff_out == rbuff_in, 'read renderbuff equals written renderbuff')

      ! Finish

      return

   end subroutine test_io

   !****

   subroutine render_tri(rbuff, x_min, x_max, y_min, y_max, z, orient)

      type(renderbuff_t), intent(inout) :: rbuff
      real(RD), intent(in)              :: x_min
      real(RD), intent(in)              :: x_max
      real(RD), intent(in)              :: y_min
      real(RD), intent(in)              :: y_max
      real(RD), intent(in)              :: z
      character(*), intent(in)          :: orient

      real(RD)                    :: x_mid
      real(RD)                    :: y_mid
      type(point_t)               :: rect_points(9)
      integer                     :: i
      real(RD), allocatable       :: rect_scalars(:,:)
      type(vector_t), allocatable :: rect_vectors(:,:)

      ! Render a triangle within the supplid bounding box

      x_mid = 0.5_RD*(x_min + x_max)
      y_mid = 0.5_RD*(y_min + y_max)

      call from_array(RESHAPE([ &
         x_min, y_min, z, &
         x_mid, y_min, z, &
         x_max, y_min, z, &
         x_min, y_mid, z, &
         x_mid, y_mid, z, &
         x_max, y_mid, z, &
         x_min, y_max, z, &
         x_mid, y_max, z, &
         x_max, y_max, z], &
         SHAPE=[3, 9]), rect_points)

      allocate(rect_scalars(rbuff%n_scalar,3))
      do i = 1, rbuff%n_scalar
         rect_scalars(i,:) = REAL(i, RD)
      end do

      allocate(rect_vectors(rbuff%n_vector,3))
      do i = 1, rbuff%n_vector
         rect_vectors(i,:) = REAL(i, RD)*vector_t(1._RD, 1._RD, 1._RD)
      end do

      select case(orient)
      case('L')
         call rbuff%render_triangle(rect_points([7, 1, 6]), rect_scalars, rect_vectors)
      case('B')
         call rbuff%render_triangle(rect_points([1, 3, 8]), rect_scalars, rect_vectors)
      case('R')
         call rbuff%render_triangle(rect_points([3, 9, 4]), rect_scalars, rect_vectors)
      case('T')
         call rbuff%render_triangle(rect_points([9, 7, 2]), rect_scalars, rect_vectors)
      case('TL')
         call rbuff%render_triangle(rect_points([7, 1, 9]), rect_scalars, rect_vectors)
      case('BL')
         call rbuff%render_triangle(rect_points([1, 3, 7]), rect_scalars, rect_vectors)
      case('BR')
         call rbuff%render_triangle(rect_points([3, 9, 1]), rect_scalars, rect_vectors)
      case('TR')
         call rbuff%render_triangle(rect_points([9, 7, 3]), rect_scalars, rect_vectors)
      case default
         @:ABORT('invalid orient')
      end select

      ! Finish

      return

   end subroutine render_tri

   !****

   subroutine render_square(rbuff, x_min, x_max, y_min, y_max, z)

      type(renderbuff_t), intent(inout) :: rbuff
      real(RD), intent(in)              :: x_min
      real(RD), intent(in)              :: x_max
      real(RD), intent(in)              :: y_min
      real(RD), intent(in)              :: y_max
      real(RD), intent(in)              :: z

      ! Render a square within the supplied bounding box

      call render_tri(rbuff, x_min, x_max, y_min, y_max, z, 'BR')
      call render_tri(rbuff, x_min, x_max, y_min, y_max, z, 'TL')

      ! Finish

      return

   end subroutine render_square

   !****

   function check_depths(rbuff, z) result(same)

      real(RD), parameter :: TOL = 1E-15_RD

      type(renderbuff_t), intent(in) :: rbuff
      real(RD), intent(in)           :: z(:,:)
      logical                        :: same

      integer  :: i_x
      integer  :: i_y
      real(RD) :: rbuff_z(rbuff%n_x,rbuff%n_y)

      ! Check the renderbuff depth buffer

      do i_y = 1, rbuff%n_y
         do i_x = 1, rbuff%n_x
            rbuff_z(i_x,i_y) = rbuff%pixel_depth(i_x, i_y)
         end do
      end do

      same = ALL(ABS(rbuff_z - z) < TOL)

      ! Finish

      return

   end function check_depths

   !****

   function check_scalars(rbuff) result(same)

      real(RD), parameter :: TOL = 1E-15_RD

      type(renderbuff_t), intent(in) :: rbuff
      logical                        :: same

      integer  :: i
      integer  :: i_x
      integer  :: i_y
      real(RD) :: rbuff_scalar(rbuff%n_x,rbuff%n_y)

      ! Check the renderbuff scalar buffers

      same = .TRUE.

      do i = 1, rbuff%n_scalar

         do i_y = 1, rbuff%n_y
            do i_x = 1, rbuff%n_x
               rbuff_scalar(i_x,i_y) = rbuff%pixel_scalar(i,i_x,i_y)
            end do
         end do

         same = same .AND. ALL(ABS(rbuff_scalar - REAL(i, RD)) < TOL)

      end do

      ! Finish

      return

   end function check_scalars

   !****

   function check_vectors(rbuff) result(same)

      real(RD), parameter :: TOL = 1E-15_RD

      type(renderbuff_t), intent(in) :: rbuff
      logical                        :: same

      integer        :: i
      integer        :: i_x
      integer        :: i_y
      type(vector_t) :: rbuff_vector(rbuff%n_x,rbuff%n_y)

      ! Check the renderbuff vector buffers

      same = .TRUE.

      do i = 1, rbuff%n_vector

         do i_y = 1, rbuff%n_y
            do i_x = 1, rbuff%n_x
               rbuff_vector(i_x,i_y) = rbuff%pixel_vector(i,i_x,i_y)
            end do
         end do

         same = same .AND. ALL(NORM2(rbuff_vector - REAL(i, RD)*vector_t(1._RD, 1._RD, 1._RD)) < TOL)

      end do

      ! Finish

      return

   end function check_vectors

end program utest_renderbuff
