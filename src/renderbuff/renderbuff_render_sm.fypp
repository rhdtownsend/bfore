! Submodule : renderbuff_m
! Purpose   : Rendering routines for renderbuff_t

#:include 'forum.inc'

submodule(renderbuff_m) renderbuff_render_sm

   ! Uses

   use transform_m
   use point_m
   use vector_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Procedures

contains

   module procedure render

      integer           :: v
      integer           :: i
      type(point_t)     :: points(mesh%n_vert)
      real(RD)          :: scalars(mesh%n_scalar,mesh%n_vert)
      type(vector_t)    :: vectors(mesh%n_vector,mesh%n_vert)
      type(transform_t) :: tform_camera
      type(transform_t) :: tform_pixel
      integer           :: f
      type(vector_t)    :: A
      integer           :: f_e
      integer           :: v1
      integer           :: v2
      integer           :: v3

      @:ASSERT_DEBUG(mesh%n_scalar == self%n_scalar, 'dimension mismatch')
      @:ASSERT_DEBUG(mesh%n_vector== self%n_vector, 'dimension mismatch')

      ! Extract vertex data from the mesh

      vert_loop: do v = 1, mesh%n_vert

         points(v) = mesh%vert_point(v)

         do i = 1, mesh%n_scalar
            scalars(i,v) = mesh%vert_scalar(i, v)
         end do

         do i = 1, mesh%n_vector
            vectors(i,v) = mesh%vert_vector(i, v)
         end do

      end do vert_loop

      ! Apply transformations

      tform_camera = view%camera_transform()
      tform_pixel = view%pixel_transform(self%n_x, self%n_y)

      points = points%image(tform_pixel)
      vectors = vectors%image(tform_camera)

      ! Loop through faces of mesh, rendering each one

      face_loop: do f = 1, mesh%n_face

         ! Get the face area vector, and transform to the camera
         ! system

         A = mesh%face_area(f)
         A = A%image(tform_camera)

         ! Cull back-faces

         if (A%z <= 0._RD) cycle face_loop

         ! Render the face

         f_e = mesh%face_edge(f)

         v1 = mesh%edge_vert(f_e)
         v2 = mesh%edge_vert(mesh%edge_next(f_e))
         v3 = mesh%edge_vert(mesh%edge_prev(f_e))

         call render_triangle(self, &
            points([v1, v2, v3]), scalars(:,[v1, v2, v3]), vectors(:,[v1, v2, v3]), tag)

      end do face_loop

      ! Finish

      return

   end procedure render

   !****

   module procedure render_triangle

      integer  :: i_x_min
      integer  :: i_x_max
      integer  :: i_y_min
      integer  :: i_y_max
      real(RD) :: area2
      real(RD) :: inv_area2
      real(RD) :: EF_a(3)
      real(RD) :: EF_b(3)
      real(RD) :: EF_c(3)
      logical  :: EF_tie(3)
      integer  :: i_x
      integer  :: i_y
      logical  :: any_inside
      real(RD) :: EF(3)
      logical  :: inside
      real(RD) :: lambda(3)
      real(RD) :: depth
      integer  :: i

      @:CHECK_BOUNDS(SIZE(points), 3)

      @:CHECK_BOUNDS(SIZE(scalars, 1), self%n_scalar)
      @:CHECK_BOUNDS(SIZE(scalars, 2), 3)

      @:CHECK_BOUNDS(SIZE(vectors, 1), self%n_vector)
      @:CHECK_BOUNDS(SIZE(vectors, 2), 3)

      ! Render a triangle. The algorithm largely follows that
      ! described by Pineda (1988)

      ! Determine the pixel bounding box

      i_x_min = MAX(FLOOR(MINVAL(points%x)), 1)
      i_x_max = MIN(CEILING(MAXVAL(points%x)), self%n_x)

      i_y_min = MAX(FLOOR(MINVAL(points%y)), 1)
      i_y_max = MIN(CEILING(MAXVAL(points%y)), self%n_y)

      ! Check if the bounding box is null

      if (i_x_min > i_x_max .OR. i_y_min > i_y_max) return

      ! Calculate quantities used in edge-function evaluation

      EF_a = points([2, 3, 1])%y - points([3, 1, 2])%y
      EF_b = points([3, 1, 2])%x - points([2, 3, 1])%x
      EF_c = points([2, 3, 1])%x*points([3, 1, 2])%y - points([3, 1, 2])%x*points([2, 3, 1])%y

      ! Calculate twice the projected area of the triangle, returning
      ! if it is small (indicating an edge-on triangle)

      area2 = SUM(EF_c)

      if (ABS(area2) < EPSILON(0._RD)) return

      inv_area2 = 1._RD/area2

      ! Calculate the tie-breaker function, based on Fig. 2 of McCool,
      ! Wales & Moule (2002), modified to follow the OpenGL fill-rule
      ! convention that top/left edges are drawn

      EF_tie = EF_a > 0._RD .OR. (EF_a == 0._RD .AND. EF_b < 0._RD)

      ! Loop through the pixels within the bounding box

      y_loop: do i_y = i_y_min, i_y_max

         any_inside = .FALSE.

         x_loop: do i_x = i_x_min, i_x_max

            ! Evaluate the edge functions

            EF = i_x*EF_a + i_y*EF_b + EF_c

            ! Determine if the pixel lies within the triangle

            inside = ALL(EF > 0._RD .OR. (EF == 0._RD .AND. EF_tie))

            if (inside) then

               ! Evaluate normalized barycentric coordinates

               lambda = inv_area2*EF

               ! Perform the depth test

               depth = DOT_PRODUCT(lambda, points%z)

               if (depth > self%PD(i_x,i_y)) then

                  ! Store the depth

                  self%PD(i_x,i_y) = depth

                  ! Store the tag

                  if (PRESENT(tag)) self%PT(i_x,i_y) = tag

                  ! Store the scalars and vectors

                  do i = 1, self%n_scalar
                     self%PS(i,i_x,i_y) = SUM(scalars(i,:)*lambda)
                  end do

                  do i = 1, self%n_vector
                     self%PV(i,i_x,i_y) = sum(vectors(i,:)*lambda)
                  end do

                  ! Flag that at least one pixel on this scanline was
                  ! inside

                  any_inside = .TRUE.

               end if

            else

               ! Check if the scaline is done

               if (any_inside) exit x_loop

            end if

         end do x_loop
      end do y_loop

      ! Finish

      return

   end procedure render_triangle

end submodule renderbuff_render_sm
