! Module  : special_m
! Purpose : Special mathematical functions

#:include 'forum.inc'

module special_m

   ! Uses

   use forum_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none

   ! Access specifiers

   private

   public :: factorial
   public :: double_factorial
   public :: legendre_P
   public :: spherical_Y
   public :: spherical_rgrad_Y_theta
   public :: spherical_rgrad_Y_phi
   public :: spherical_N

   ! Procedures

contains

   function factorial(n) result(f)

      integer, intent(in) :: n
      real(RD)            :: f

      @:ASSERT_DEBUG(n >= 0, 'Invalid n')

      ! Evaluate the factorial n!

      f = GAMMA(REAL(n+1, RD))

   end function factorial

   !****

   function double_factorial(n) result(f)

      integer, intent(in) :: n
      real(RD)            :: f

      integer :: k

      @:ASSERT_DEBUG(n >= -1, 'Invalid n')

      ! Evaluate the double factorial n!!

      if (n == 0) then

         f = 1._RD

      elseif (MOD(n, 2) == 0) then

         k = n/2
         f = 2**k*factorial(k)

      else

         k = (n+1)/2
         f = factorial(2*k)/(2**k*factorial(k))

      end if

   end function double_factorial

   !****

   function legendre_P(l, m, x) result(P)

      integer, intent(in)  :: l
      integer, intent(in)  :: m
      real(RD), intent(in) :: x
      real(RD)             :: P

      integer  :: am
      real(RD) :: y
      real(RD) :: P_1
      real(RD) :: P_2
      integer  :: k

      @:ASSERT(ABS(x) <= 1, 'Invalid x')

      ! Evaluate the associated Legendre function P^m_l(x) with degree
      ! l and order m. The definitions given by Abramowitz & Stegun
      ! (1970) are adopted --- in particular, their eqn. 8.6.6, which
      ! uses the Condon-Shortley phase term

      am = ABS(m)

      if (am > l) then

         P = 0

      elseif (l < 0) then

         P = 0

      else

         y = SQRT((1-x) * (1+x))
         P = (-1)**am * double_factorial(2*am-1) * y**am

         if (l > am) then

            P_1 = P
            P = x*(2*am+1)*P_1

            do k = am+2, l
               P_2 = P_1
               P_1 = P
               P = ((2*k-1)*x*P_1 - (k+am-1)*P_2)/(k-am)
            end do

         endif

         if (m < 0) then
            P = (-1)**am*factorial(l-am)/factorial(l+am)*P
         endif

      end if

   end function legendre_P

   !****

   function spherical_Y(l, m, theta, phi) result(Y)

      integer, intent(in)  :: l
      integer, intent(in)  :: m
      real(RD), intent(in) :: theta
      real(RD), intent(in) :: phi
      complex(RD)          :: Y

      real(RD) :: ctheta

      ! Evaluate the spherical harmonic Y^m_l with degree l and order
      ! m

      ctheta = COS(theta)

      Y = spherical_N(l, m) * legendre_P(l, m, ctheta) * EXP(CMPLX(0._RD, m*phi, RD))

      ! Finish

      return

   end function spherical_Y

   !****

   function spherical_rgrad_Y_theta(l, m, theta, phi) result(rgrad_Y_theta)

      integer, intent(in)  :: l
      integer, intent(in)  :: m
      real(RD), intent(in) :: theta
      real(RD), intent(in) :: phi
      complex(RD)          :: rgrad_Y_theta

      real(RD) :: ctheta

      ! Evaluate the theta component of (r grad) (Y^m_l)

      ctheta = COS(theta)

      rgrad_Y_theta = -spherical_N(l, m) * &
         ((l+m)*(l-m+1)*legendre_P(l, m-1, ctheta) - legendre_P(l, m+1, ctheta))/2 * &
         EXP(CMPLX(0._RD, m*phi, RD))

   end function spherical_rgrad_Y_theta

   !****

   function spherical_rgrad_Y_phi(l, m, theta, phi) result(rgrad_Y_phi)

      integer, intent(in)  :: l
      integer, intent(in)  :: m
      real(RD), intent(in) :: theta
      real(RD), intent(in) :: phi
      complex(RD)          :: rgrad_Y_phi

      real(RD) :: ctheta

      ! Evaluate the phi component of (r grad) (Y^m_l)

      ctheta = COS(theta)

      rgrad_Y_phi = -spherical_N(l, m) * &
         (legendre_P(l-1, m+1, ctheta) + (l+m)*(l+m-1)*legendre_P(l-1, m-1, ctheta))/2 * &
         EXP(CMPLX(0._RD, m*phi+HALFPI, RD))

   end function spherical_rgrad_Y_phi

   !****

   function spherical_N(l, m) result(N)

      integer, intent(in) :: l
      integer, intent(in) :: m
      real(RD)            :: N

      ! Evaluate the spherical harmonic normalization factor N^m_l

      N = SQRT((2*l+1)/(4*PI)*factorial(l-m)/factorial(l+m))

   end function spherical_N

end module special_m
